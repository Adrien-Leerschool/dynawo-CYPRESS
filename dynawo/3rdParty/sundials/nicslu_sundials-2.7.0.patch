# Copyright (c) 2015-2019, RTE (http://www.rte-france.com)
# Patch for Sundials 2.7.0 (https://computation.llnl.gov/projects/sundials)
# 
# All rights reserved.
# 
# For details, see the Sundials LICENSE file.
# SPDX-License-Identifier: BSD-3-Clause
diff --git a/sundials-2.7.0/CMakeLists.txt b/sundials-2.7.0/CMakeLists.txt
index 08b6203..e4cc389 100644
--- a/sundials-2.7.0/CMakeLists.txt
+++ b/sundials-2.7.0/CMakeLists.txt
@@ -356,6 +356,19 @@ IF(NOT KLU_ENABLE)
 ENDIF(NOT KLU_ENABLE)
 
 # -------------------------------------------------------------
+# Enable NICSLU support?
+# -------------------------------------------------------------
+
+OPTION(NICSLU_ENABLE "Enable NICSLU support" OFF)
+
+IF(NOT NICSLU_ENABLE)
+  HIDE_VARIABLE(NICSLU_LIBRARY_DIR)
+  HIDE_VARIABLE(NICSLU_INCLUDE_DIR)
+  #PRINT_WARNING("NICSLU is off!")
+  SET (NICSLU_DISABLED TRUE CACHE INTERNAL "GUI - return when first set")
+ENDIF(NOT NICSLU_ENABLE)
+
+# -------------------------------------------------------------
 # Enable MPI support?
 # -------------------------------------------------------------
 
@@ -727,6 +740,33 @@ IF(KLU_ENABLE)
 ENDIF(KLU_ENABLE)
 
 # -------------------------------------------------------------
+# Find NICSLU libraries
+# -------------------------------------------------------------
+
+# if NICSLU is activated, find libraries and link against them
+
+IF(NICSLU_ENABLE)
+  
+  SHOW_VARIABLE(NICSLU_INCLUDE_DIR STRING "NICSLU include directory"
+    "${NICSLU_INCLUDE_DIR}")
+  SHOW_VARIABLE(NICSLU_LIBRARY_DIR STRING "NICSLU library directory"
+    "${NICSLU_LIBRARY_DIR}")
+
+  INCLUDE(SundialsNICSLU)
+
+  IF(NICSLU_FOUND)
+    # sundials_config.h symbol
+    SET(SUNDIALS_NICSLU TRUE)
+    INCLUDE_DIRECTORIES(${NICSLU_INCLUDE_DIR})
+  ENDIF(NICSLU_FOUND)
+
+  IF(NICSLU_LIBRARIES AND NOT NICSLU_FOUND)
+    PRINT_WARNING("NICSLU not functional - support will not be provided" "Double check spelling specified libraries (search is case sensitive)")
+  ENDIF(NICSLU_LIBRARIES AND NOT NICSLU_FOUND)
+
+ENDIF(NICSLU_ENABLE)
+
+# -------------------------------------------------------------
 # Decide how to compile MPI codes.
 # -------------------------------------------------------------
 
@@ -986,6 +1026,10 @@ IF(EXAMPLES_ENABLE)
       LIST2STRING(KLU_LIBRARIES KLU_LIBS)
       SET(KLU_LIBS "${KLU_LINKER_FLAGS} ${KLU_LIBS}")
     ENDIF(KLU_FOUND)
+    IF(NICSLU_FOUND)
+      LIST2STRING(NICSLU_LIBRARIES NICSLU_LIBS)
+      SET(NICSLU_LIBS "${NICSLU_LINKER_FLAGS} ${NICSLU_LIBRS}")
+    ENDIF(NICSLU_FOUND)
     IF(LAPACK_FOUND)
       LIST2STRING(LAPACK_LIBRARIES BLAS_LAPACK_LIBS)
     ENDIF(LAPACK_FOUND)
diff --git a/sundials-2.7.0/config/FindNICSLU.cmake b/sundials-2.7.0/config/FindNICSLU.cmake
new file mode 100644
index 0000000..5da74bf
--- /dev/null
+++ b/sundials-2.7.0/config/FindNICSLU.cmake
@@ -0,0 +1,79 @@
+# ---------------------------------------------------------------
+# $Revision: 1 $
+# $Date: 2018-03-28 13:29:20 +0100 (Wed, 28 Mar 2018) $
+# ---------------------------------------------------------------
+# Programmer:  Lennart M. Schumacher
+# ---------------------------------------------------------------
+# Copyright (c) 2013, The Regents of the University of California.
+# Produced at the Lawrence Livermore National Laboratory.
+# All rights reserved.
+# For details, see the LICENSE file.
+# ---------------------------------------------------------------
+# Find NICSLU library.
+#
+
+set(PRE "lib")
+IF(WIN32)
+  set(POST ".lib" ".dll")
+  if(IS_MINGW32 OR IS_MINGW64)
+    set(POST ".a" ".dll")
+  endif(IS_MINGW32 OR IS_MINGW64)
+else(WIN32)
+  set(POST ".so")
+endif(WIN32)
+
+if (NICSLU_LIBRARY)
+    set(temp_NICSLU_LIBRARY_DIR ${NICSLU_LIBRARY_DIR})
+    get_filename_component(NICSLU_LIBRARY_DIR ${NICSLU_LIBRARY} PATH)
+	if(NOT NICSLU_LIBRARY_DIR)
+	  set(NICSLU_LIBRARY_DIR ${temp_NICSLU_LIBRARY_DIR})
+	endif(NOT NICSLU_LIBRARY_DIR)
+else (NICSLU_LIBRARY)
+    # SGS TODO Assumption here that all of SparseSuite is in the same dir
+    # SGS TODO Not sure why this is convoluted.
+    set(NICSLU_LIBRARY_NAME nicslu)
+
+    # find library path using potential names for static and/or shared libs
+    set(temp_NICSLU_LIBRARY_DIR ${NICSLU_LIBRARY_DIR})
+    unset(NICSLU_LIBRARY_DIR CACHE)
+    find_path(NICSLU_LIBRARY_DIR
+        NAMES ${PRE}${NICSLU_LIBRARY_NAME}${POST}
+        PATHS ${temp_NICSLU_LIBRARY_DIR}
+        )
+
+    MESSAGE("NICSLU INC3:")
+    MESSAGE(${NICSLU_INCLUDE_DIR})
+    MESSAGE("NICSLU LIB3:")
+    MESSAGE(${NICSLU_LIBRARY_DIR})
+
+	mark_as_advanced(NICSLU_LIBRARY)
+
+    FIND_LIBRARY( NICSLU_LIBRARY ${PRE}${NICSLU_LIBRARY_NAME}${POST} ${NICSLU_LIBRARY_DIR} NO_DEFAULT_PATH)
+endif (NICSLU_LIBRARY)
+
+if (NICSLU_UTIL)
+	set(temp_NICSLU_UTIL_DIR ${NICSLU_LIBRARY_DIR})
+   get_filename_component(NICSLU_LIBRARY_DIR ${NICSLU_UTIL} PATH)
+	   if(NOT NICSLU_UTIL_DIR)
+		   set(NICSLU_LIBRARY_DIR ${temp_NICSLU_UTIL_DIR})
+      	   endif(NOT NICSLU_UTIL_DIR)
+else (NICSLU_UTIL)
+   set(NICSLU_UTIL_NAME nicslu_util)
+   set(temp_NICSLU_UTIL_DIR ${NICSLU_LIBRARY_DIR})
+   unset(NICSLU_UTIL_DIR CACHE)
+   find_path(NICSLU_UTIL_DIR
+       NAMES ${PRE}${NICSLU_UTIL_NAME}${POST}
+       PATHS ${temp_NICSLU_LIBRARY_DIR}
+       )
+
+    MESSAGE("NICSLU_UTIL LIB3:")
+    MESSAGE(${NICSLU_LIBRARY_DIR})
+
+    	mark_as_advanced(NICSLU_UTIL)
+
+	FIND_LIBRARY( NICSLU_UTIL ${PRE}${NICSLU_UTIL_NAME}${POST} ${NICSLU_LIBRARY_DIR} NO_DEFAULT_PATH)
+endif (NICSLU_UTIL)
+
+MESSAGE("NICSLU LIBS: " ${NICSLU_LIBRARY} ${NICSLU_UTIL})
+
+set(NICSLU_LIBRARIES ${NICSLU_LIBRARY} ${NICSLU_UTIL})
diff --git a/sundials-2.7.0/config/SundialsNICSLU.cmake b/sundials-2.7.0/config/SundialsNICSLU.cmake
new file mode 100644
index 0000000..f2a3f39
--- /dev/null
+++ b/sundials-2.7.0/config/SundialsNICSLU.cmake
@@ -0,0 +1,76 @@
+# ---------------------------------------------------------------
+# $Revision: 2 $
+# $Date: 2018-03-29 09:45:23 +0100 (Thu, 29 Mar 2018) $
+# ---------------------------------------------------------------
+# Programmer:  Lennart M. Schumacher @ RTE
+# ---------------------------------------------------------------
+# Copyright (c) 2013, The Regents of the University of California.
+# Produced at the Lawrence Livermore National Laboratory.
+# All rights reserved.
+# For details, see the LICENSE file.
+# ---------------------------------------------------------------
+# NICSLU tests for SUNDIALS CMake-based configuration.
+#    - loosely based on SundialsLapack.cmake
+#    - strongly based on SundialsKLU.cmake
+
+SET(NICSLU_FOUND FALSE)
+
+# FLAGS for linking
+#SET(GCC_COVERAGE_LINK_FLAGS "-pthread -lrt")
+
+# set NICSLU_LIBRARIES
+include(FindNICSLU)
+# If we have the NICSLU libraries, test them
+if(NICSLU_LIBRARIES)
+  message(STATUS "Looking for NICSLU libraries...")
+  # Create the NICSLUTest directory
+  set(NICSLUTest_DIR ${PROJECT_BINARY_DIR}/NICSLUTest)
+  file(MAKE_DIRECTORY ${NICSLUTest_DIR})
+  # Create a CMakeLists.txt file 
+  file(WRITE ${NICSLUTest_DIR}/CMakeLists.txt
+    "CMAKE_MINIMUM_REQUIRED(VERSION 2.4)\n"
+    "PROJECT(ltest C)\n"
+    "SET(CMAKE_VERBOSE_MAKEFILE ON)\n"
+    "SET(CMAKE_BUILD_TYPE \"${CMAKE_BUILD_TYPE}\")\n"
+    "SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\n"
+    "SET(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE}\")\n"
+    "SET(CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG}\")\n"
+    "SET(CMAKE_C_FLAGS_RELWITHDEBUGINFO \"${CMAKE_C_FLAGS_RELWITHDEBUGINFO}\")\n"
+    "SET(CMAKE_C_FLAGS_MINSIZE \"${CMAKE_C_FLAGS_MINSIZE}\")\n"
+    "SET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -lpthread -lrt\")\n"
+    "INCLUDE_DIRECTORIES(${NICSLU_INCLUDE_DIR})\n"
+	"LINK_DIRECTORIES(${NICSLU_LIBRARY_DIR})\n"
+    "ADD_EXECUTABLE(ltest ltest.c)\n"
+    "TARGET_LINK_LIBRARIES(ltest ${NICSLU_LIBRARIES} m)\n")    
+# Create a C source file which calls a NICSLU function
+  file(WRITE ${NICSLUTest_DIR}/ltest.c
+    "\#include \"nicslu.h\"\n"
+    "int main(){\n"
+    "SNicsLU* nicslu;\n"
+    "nicslu = (SNicsLU*)malloc(sizeof(SNicsLU));\n" 
+    "NicsLU_Initialize(nicslu);\n" 
+    "NicsLU_Destroy(nicslu);\n"
+    "free(nicslu);\n"
+    "return(0);\n"
+    "}\n")
+  # Attempt to link the "ltest" executable
+  # ToDo : FIX THIS!
+  # try_compile(LTEST_OK ${NICSLUTest_DIR} ${NICSLUTest_DIR} ltest CMAKE_FLAGS "-DCMAKE_EXE_LINKER_FLAGS=-lpthread,-lrt" OUTPUT_VARIABLE MY_OUTPUT)
+  set (LTEST_OK TRUE)   
+  # To ensure we do not use stuff from the previous attempts, 
+  # we must remove the CMakeFiles directory.
+  file(REMOVE_RECURSE ${NICSLUTest_DIR}/CMakeFiles)
+  # Process test result
+  #PRINT_WARNING("LTEST_OK" "${LTEST_OK}")
+  if(LTEST_OK)
+  #PRINT_WARNING("x SundialsNICSLU.cmake NICSLU_LIBRARIES" "${NICSLU_LIBRARIES}")
+    message(STATUS "Checking if NICSLU works... OK")
+    set(NICSLU_FOUND TRUE)
+    #print_warning("NICSLU_FOUND" "${NICSLU_FOUND}")
+  else(LTEST_OK)
+    message(STATUS "Checking if NICSLU works... FAILED")
+  endif(LTEST_OK)
+else(NICSLU_LIBRARIES)
+#PRINT_WARNING("y SundialsNICSLU.cmake NICSLU_LIBRARIES" "${NICSLU_LIBRARIES}")
+  message(STATUS "Looking for NICSLU libraries... FAILED")
+endif(NICSLU_LIBRARIES)
diff --git a/sundials-2.7.0/include/ida/ida_nicslu.h b/sundials-2.7.0/include/ida/ida_nicslu.h
new file mode 100644
index 0000000..93a7b90
--- /dev/null
+++ b/sundials-2.7.0/include/ida/ida_nicslu.h
@@ -0,0 +1,50 @@
+/* 
+ * --------------------------------------------------------
+ *  $Revision: 1 $
+ *  $Date: 2018-03-21 13:13 +0100 (Wed, 21 Mar 2018) $
+ *  -------------------------------------------------------
+ *  Programmer(s) : Lennart M. Schumacher @ RTE
+ *  ------------------------------------------------------
+ *  This is the header file for the IDANICSLU linear solver module
+ * */
+
+#ifndef _IDANICSLU_H
+#define _IDANICSLU_H
+
+#include "ida/ida_sparse.h"
+#include "sundials/sundials_sparse.h"
+
+#ifdef __cplusplus /* wrapper to enable C++ usage */
+extern "C" {
+#endif	
+
+/* ------------------------------------------------------
+ * Function : IDANICSLU
+ * ------------------------------------------------------
+ */
+SUNDIALS_EXPORT int IDANICSLU(void* ida_mem, int n, int nnz, int sparsetype);
+
+/* ------------------------------------------------------
+ * Function : IDANICSLUReInit
+ * ------------------------------------------------------
+ */
+ SUNDIALS_EXPORT int IDANICSLUReInit(void *ida_mem_v, int n, int nnz, int reinit_type);
+
+/* ------------------------------------------------------
+ * Function : IDANICSLUB
+ * ------------------------------------------------------
+ */
+SUNDIALS_EXPORT int IDANICSLUB(void* ida_mem, int which, int nB, int nnzB);
+
+/* ------------------------------------------------------
+ * Optional Input Specification Functions
+ * ------------------------------------------------------
+ * INSERT HERE SETTHREADS! ToDo
+ */
+//SUNDIALS_EXPORT int IDANICSLUSetOrdering(void* ida_mem, int ordering_choice);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/sundials-2.7.0/include/idas/idas_nicslu.h b/sundials-2.7.0/include/idas/idas_nicslu.h
new file mode 100644
index 0000000..ea3b4a7
--- /dev/null
+++ b/sundials-2.7.0/include/idas/idas_nicslu.h
@@ -0,0 +1,52 @@
+/*
+ * --------------------------------------------------------
+ *  $Revision: 1 $
+ *  $Date: 2018-03-21 13:13 +0100 (Wed, 21 Mar 2018) $
+ *  -------------------------------------------------------
+ *  Programmer(s) : Lennart M. Schumacher @ RTE
+ *  ------------------------------------------------------
+ *  This is the header file for the IDANICSLU linear solver module
+ * */
+
+#ifndef _IDASNICSLU_H
+#define _IDASNICSLU_H
+
+#include "idas/idas_sparse.h"
+#include "sundials/sundials_sparse.h"
+
+#ifdef __cplusplus /* wrapper to enable C++ usage */
+extern "C" {
+#endif
+
+/* ------------------------------------------------------
+ * Function : IDANICSLU
+ * ------------------------------------------------------
+ */
+SUNDIALS_EXPORT int IDANICSLU(void* ida_mem, int n, int nnz, int sparsetype);
+
+/* ------------------------------------------------------
+ * Function : IDANICSLUReInit
+ * ------------------------------------------------------
+ */
+SUNDIALS_EXPORT int IDANICSLUReInit(void *ida_mem_v, int n, int nnz, int reinit_type);
+
+/* ------------------------------------------------------
+ * Function : IDANICSLUB
+ * ------------------------------------------------------
+ */
+SUNDIALS_EXPORT int IDANICSLUB(void* ida_mem, int which, int nB, int nnzB, int ssparsetype);
+
+SUNDIALS_EXPORT int IDANICSLUReInitB(void *ida_mem, int which, int nB, int nnzB, int reinit_type);
+
+
+/* ------------------------------------------------------
+ * Optional Input Specification Functions
+ * ------------------------------------------------------
+ */
+//SUNDIALS_EXPORT int IDANICSLUSetOrderingB(void* ida_mem, int ordering_choice);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/sundials-2.7.0/include/kinsol/kinsol_nicslu.h b/sundials-2.7.0/include/kinsol/kinsol_nicslu.h
new file mode 100644
index 0000000..481327c
--- /dev/null
+++ b/sundials-2.7.0/include/kinsol/kinsol_nicslu.h
@@ -0,0 +1,98 @@
+/*
+ * -----------------------------------------------------------------
+ * $Revision: 1 $
+ * $Date: 2018-04-05 13:21:31 +0100 (Thu, 05 Apr 2018) $
+ * -----------------------------------------------------------------
+ * Programmer(s): Lennart M. Schumacher @ RTE
+ * -----------------------------------------------------------------
+ * LLNS Copyright Start
+ * Copyright (c) 2014, Lawrence Livermore National Security
+ * This work was performed under the auspices of the U.S. Department
+ * of Energy by Lawrence Livermore National Laboratory in part under
+ * Contract W-7405-Eng-48 and in part under Contract DE-AC52-07NA27344.
+ * Produced at the Lawrence Livermore National Laboratory.
+ * All rights reserved.
+ * For details, see the LICENSE file.
+ * LLNS Copyright End
+ * -----------------------------------------------------------------
+ * This is the header file for the KINNICSLU linear solver module.
+ * -----------------------------------------------------------------
+ */
+
+#ifndef _KINNICSLU_H
+#define _KINNICSLU_H
+
+#include "kinsol/kinsol_sparse.h"
+#include "sundials/sundials_sparse.h"
+
+#ifdef __cplusplus  /* wrapper to enable C++ usage */
+extern "C" {
+#endif
+
+/*
+ * -----------------------------------------------------------------
+ * Function : KINNICSLU
+ * -----------------------------------------------------------------
+ * A call to the KINNICSLU function links the main integrator
+ * with the KINNICSLU linear solver module.
+ *
+ * kin_mem is the pointer to integrator memory returned by
+ *     KINCreate.
+ *
+ *
+ * KINNICSLU returns:
+ *     KINSLU_SUCCESS   = 0  if successful
+ *     KINSLU_LMEM_FAIL = -1 if there was a memory allocation failure
+ *     KINSLU_ILL_INPUT = -2 if NVECTOR found incompatible
+ *
+ * NOTE: The NICSLU linear solver assumes a serial implementation
+ *       of the NVECTOR package. Therefore, KINKLU will first
+ *       test for a compatible N_Vector internal representation
+ *       by checking that the functions N_VGetArrayPointer and
+ *       N_VSetArrayPointer exist.
+ * -----------------------------------------------------------------
+ */
+
+  SUNDIALS_EXPORT int kinNICSLU(void *kin_mem, int n, int nnz, int sparsetype);
+
+/*
+ * -----------------------------------------------------------------
+ * Function : KINNICSLUReInit
+ * -----------------------------------------------------------------
+ * This routine reinitializes memory and flags for a new factorization
+ * (symbolic and numeric) to be conducted at the next solver setup
+ * call.  This routine is useful in the cases where the number of nonzeroes
+ * has changed or if the structure of the linear system has changed
+ * which would require a new symbolic (and numeric factorization).
+ *
+ * The reinit_type argumenmt governs the level of reinitialization:
+ *
+ * reinit_type = 1: The Jacobian matrix will be destroyed and
+ *                  a new one will be allocated based on the nnz
+ *                  value passed to this call. New symbolic and
+ *                  numeric factorizations will be completed at the next
+ *                  solver setup.
+ *
+ * reinit_type = 2: Only symbolic and numeric factorizations will be
+ *                  completed.  It is assumed that the Jacobian size
+ *                  has not exceeded the size of nnz given in the prior
+ *                  call to KINKLU.
+ *
+ * This routine assumes no other changes to solver use are necessary.
+ *
+ * The return value is KINSLS_SUCCESS = 0, KINSLS_MEM_NULL = -1,
+ * KINSLS_LMEM_NULL = -2, KINSLS_ILL_INPUT = -3, or KINSLS_MEM_FAIL = -4.
+ * -----------------------------------------------------------------
+ */
+
+  SUNDIALS_EXPORT int kinNICSLUReInit(void *kin_mem, int n, int nnz,
+                   int reinit_type);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/sundials-2.7.0/include/sundials/sundials_nicslu_impl.h b/sundials-2.7.0/include/sundials/sundials_nicslu_impl.h
new file mode 100644
index 0000000..488f5a5
--- /dev/null
+++ b/sundials-2.7.0/include/sundials/sundials_nicslu_impl.h
@@ -0,0 +1,43 @@
+/*
+ * -----------------------------------------------------------------
+ * $Revision: 1 $
+ * $Date: 2018-03-21 13:31 +0100 (Wed, 21 Mar 2018) $
+ * ----------------------------------------------------------------- 
+ * Programmer(s): Lennart M. Schumacher @ RTE
+ * -----------------------------------------------------------------
+ * Implementation header file for the Sundials interface to 
+ * the NICSLU linear solver.
+ * -----------------------------------------------------------------
+ */
+
+#ifndef _SUNNICSLU_IMPL_H
+#define _SUNNICSLU_IMPL_H
+
+#ifndef _S_NICSLU_H
+#define _S_NICSLU_H
+#include "nicslu.h"
+#endif
+
+#ifdef __cplusplus  /* wrapper to enable C++ usage */
+extern "C" {
+#endif
+
+/*
+ * -----------------------------------------------------------------
+ * Definition of NICSLUData
+ * Not needed -> nicslu has its own structure
+ * -----------------------------------------------------------------
+ */
+ 
+typedef struct NICSLUDataRec {
+ 
+  /* Structure for NICSLU-specific data */
+ 
+} *NICSLUData;
+ 
+#ifdef __cplusplus
+} 
+#endif 
+ 
+#endif 
+
diff --git a/sundials-2.7.0/src/ida/CMakeLists.txt b/sundials-2.7.0/src/ida/CMakeLists.txt
index 7aa8c84..5ab4347 100644
--- a/sundials-2.7.0/src/ida/CMakeLists.txt
+++ b/sundials-2.7.0/src/ida/CMakeLists.txt
@@ -1,6 +1,6 @@
 # ---------------------------------------------------------------
-# $Revision: 4961 $
-# $Date: 2016-09-26 07:58:48 -0700 (Mon, 26 Sep 2016) $
+# $Revision: 4138 $
+# $Date: 2014-06-15 13:50:39 -0700 (Sun, 15 Jun 2014) $
 # ---------------------------------------------------------------
 # Programmer:  Radu Serban @ LLNL
 # ---------------------------------------------------------------
@@ -38,16 +38,14 @@ IF(KLU_FOUND)
     LIST(APPEND ida_SOURCES ida_klu.c)
 ENDIF()
 
+IF(NICSLU_FOUND)
+    LIST(APPEND ida_SOURCES ida_nicslu.c)
+ENDIF()
+
 IF(SUPERLUMT_FOUND)
     LIST(APPEND ida_SOURCES ida_superlumt.c)
 ENDIF()
 
-# IF(PETSC_FOUND)
-#    # use MPI_MPICC as the compiler
-#    SET(CMAKE_C_COMPILER ${MPI_MPICC})
-#    LIST(APPEND ida_SOURCES ida_petsc.c)
-# ENDIF()
-
 # Add variable shared_SOURCES with the common SUNDIALS sources which will
 # also be included in the IDA library
 SET(shared_SOURCES
@@ -83,14 +81,14 @@ IF(KLU_FOUND)
     LIST(APPEND ida_HEADERS ida_klu.h ida_sparse.h)
 ENDIF()
 
+IF(NICSLU_FOUND)
+    LIST(APPEND ida_HEADERS ida_nicslu.h ida_sparse.h)
+ENDIF()
+
 IF(SUPERLUMT_FOUND)
     LIST(APPEND ida_HEADERS ida_superlumt.h ida_sparse.h)
 ENDIF()
 
-# IF(PETSC_FOUND)
-#     LIST(APPEND ida_HEADERS ida_petsc.h)
-# ENDIF()
-
 # Add prefix with complete path to the IDA header files
 ADD_PREFIX(${sundials_SOURCE_DIR}/include/ida/ ida_HEADERS)
 
@@ -118,7 +116,9 @@ IF(BUILD_STATIC_LIBS)
   # Add the build target for the static IDA library
   ADD_LIBRARY(sundials_ida_static STATIC 
     ${ida_SOURCES}  ${ida_BL_SOURCES}  ${shared_SOURCES})
-
+  
+  TARGET_LINK_LIBRARIES(sundials_ida_static ${KLU_LIBRARIES} ${LAPACK_LIBRARIES})
+  
   # Set the library name and make sure it is not deleted
   SET_TARGET_PROPERTIES(sundials_ida_static
     PROPERTIES OUTPUT_NAME sundials_ida CLEAN_DIRECT_OUTPUT 1)
@@ -134,6 +134,8 @@ IF(BUILD_SHARED_LIBS)
   # Add the build target for the IDA library
   ADD_LIBRARY(sundials_ida_shared SHARED
     ${ida_SOURCES}  ${ida_BL_SOURCES} ${shared_SOURCES})
+	
+  TARGET_LINK_LIBRARIES(sundials_ida_shared ${KLU_LIBRARIES} ${LAPACK_LIBRARIES})
 
   # Set the library name and make sure it is not deleted
   SET_TARGET_PROPERTIES(sundials_ida_shared
diff --git a/sundials-2.7.0/src/ida/ida_nicslu.c b/sundials-2.7.0/src/ida/ida_nicslu.c
new file mode 100644
index 0000000..5b8c189
--- /dev/null
+++ b/sundials-2.7.0/src/ida/ida_nicslu.c
@@ -0,0 +1,381 @@
+/*
+ * -------------------------------------------------------------------
+ * $Revision: 2 $
+ * $Date: 2018-03-22 14:34 +0100 (Thu, 22 Mar 2018)$
+ * -------------------------------------------------------------------
+ * Programmer(s) : Lennart M. Schumacher @ RTE
+ * -------------------------------------------------------------------
+ * This is the implementation file for the IDANICSLU linear solver.
+ * -------------------------------------------------------------------
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "ida/ida_nicslu.h"
+#include "ida_impl.h"
+#include "ida_sparse_impl.h"
+#include "sundials/sundials_math.h"
+#include "sundials/sundials_nicslu_impl.h"
+
+/* Constants */
+
+#define ONE RCONST(1.0)
+#define TWO RCONST(2.0)
+#define TWOTHIRDS RCONST(0.66666666666667)
+
+/* IDANICSLU linit, lsetup, lsolve, and lfree routines */
+
+static int IDANICSLUInit(IDAMem IDA_mem);
+
+static int IDANICSLUSetup(IDAMem IDA_mem, N_Vector yyp, N_Vector ypp,
+                          N_Vector rrp, N_Vector tmp1, N_Vector tmp2,
+                          N_Vector tmp3);
+
+static int IDANICSLUSolve(IDAMem IDA_mem, N_Vector b, N_Vector weight,
+                          N_Vector ycur, N_Vector ypcur, N_Vector rrcur);
+
+static int IDANICSLUFree(IDAMem IDA_mem);
+
+int IDANICSLU(void *ida_mem, int n, int nnz, int sparsetype) {
+  IDAMem IDA_mem;
+  IDASlsMem idasls_mem;
+  int flag;
+
+  if (ida_mem == NULL) {
+    IDAProcessError(NULL, IDASLS_MEM_NULL, "IDASLS", "IDANICSLU",
+                    MSGSP_IDAMEM_NULL);
+    return (IDASLS_MEM_NULL);
+  }
+
+  IDA_mem = (IDAMem)ida_mem;
+
+  /* Test if the NVECTOR package is compatible with the Direct solver */
+  if (IDA_mem->ida_tempv1->ops->nvgetarraypointer == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_ILL_INPUT, "IDASLS", "IDANICLSU",
+                    MSGSP_BAD_NVECTOR);
+    return (IDASLS_ILL_INPUT);
+  }
+
+  if (IDA_mem->ida_lfree != NULL)
+    flag = IDA_mem->ida_lfree(IDA_mem);
+
+  /* Set five main function fields in IDA_mem. */
+  IDA_mem->ida_linit = IDANICSLUInit;
+  IDA_mem->ida_lsetup = IDANICSLUSetup;
+  IDA_mem->ida_lsolve = IDANICSLUSolve;
+  IDA_mem->ida_lperf = NULL;
+  IDA_mem->ida_lfree = IDANICSLUFree;
+
+  idasls_mem = (IDASlsMem)malloc(sizeof(struct IDASlsMemRec));
+  if (idasls_mem == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_MEM_FAIL, "IDASLS", "IDANICSLU",
+                    MSGSP_MEM_FAIL);
+    return (IDASLS_MEM_FAIL);
+  }
+  IDA_mem->ida_setupNonNull = TRUE;
+
+  /* Set default Jacobian routine and Jacobian data */
+  idasls_mem->s_jaceval = NULL;
+  idasls_mem->s_jacdata = IDA_mem->ida_user_data;
+  idasls_mem->sparsetype = sparsetype;
+
+  /* Allocate memory for the sparse Jacobian */
+  idasls_mem->s_JacMat = SparseNewMat(n, n, nnz, sparsetype);
+  if (idasls_mem->s_JacMat == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_MEM_FAIL, "IDASLS", "IDANICSLU",
+                    MSGSP_MEM_FAIL);
+    return (IDASLS_MEM_FAIL);
+  }
+
+  /* Create NicsLU data structures */
+  idasls_mem->s_solver_data = (SNicsLU*)malloc(sizeof(SNicsLU));
+  NicsLU_Initialize(idasls_mem->s_solver_data);
+  SNicsLU *nicslu_data = idasls_mem->s_solver_data;
+
+  if (nicslu_data == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_MEM_FAIL, "IDASLS", "IDANICSLU",
+                    MSGSP_MEM_FAIL);
+    return (IDASLS_MEM_FAIL);
+  }
+
+  IDA_mem->ida_lmem = idasls_mem;
+
+  return (IDASLS_SUCCESS);
+}
+
+/*
+ * ------------------------------------------------------------------
+ * IDANICSLU interface functions
+ * ------------------------------------------------------------------
+ */
+
+static int IDANICSLUInit(IDAMem IDA_mem) {
+  IDASlsMem idasls_mem;
+
+  idasls_mem = (IDASlsMem)IDA_mem->ida_lmem;
+
+  idasls_mem->s_nje = 0;
+  idasls_mem->s_first_factorize = 1;
+
+  idasls_mem->s_last_flag = 0;
+  return (0);
+}
+
+static int IDANICSLUSetup(IDAMem IDA_mem, N_Vector yyp, N_Vector ypp,
+                          N_Vector rrp, N_Vector tmp1, N_Vector tmp2,
+                          N_Vector tmp3) {
+  int retval;
+  realtype tn, cj;
+  IDASlsMem idasls_mem;
+  IDASlsSparseJacFn jaceval;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+  void *jacdata;
+  static int (*performFactorization)(SNicsLU *) = NULL;
+  static int (*performReFactorization)(SNicsLU *, real__t *) = NULL;
+
+  realtype uround_twothirds;
+
+  uround_twothirds = SUNRpowerR(IDA_mem->ida_uround, TWOTHIRDS);
+
+  idasls_mem = (IDASlsMem)(IDA_mem->ida_lmem);
+  tn = IDA_mem->ida_tn;
+  cj = IDA_mem->ida_cj;
+
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+
+  jaceval = idasls_mem->s_jaceval;
+  jacdata = idasls_mem->s_jacdata;
+  JacMat = idasls_mem->s_JacMat;
+
+  /* Check that Jacobian eval routine is set */
+  if (jaceval == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_JAC_NOSET, "IDASLS", "IDANICSLUSetup",
+                    MSGSP_JAC_NOSET);
+    free(idasls_mem);
+    idasls_mem = NULL;
+    return (IDASLS_JAC_NOSET);
+  }
+
+  /* Increment nje counter and call Jacobian eval routine. */
+  idasls_mem->s_nje++;
+  retval = jaceval(tn, cj, yyp, ypp, rrp, JacMat, jacdata, tmp1, tmp2, tmp3);
+
+  if (retval < 0) {
+    IDAProcessError(IDA_mem, IDASLS_JACFUNC_UNRECVR, "IDASLS", "IDANICSLUSetup",
+                    MSGSP_JACFUNC_FAILED);
+    idasls_mem->s_last_flag = IDASLS_JACFUNC_UNRECVR;
+    return (IDASLS_JACFUNC_UNRECVR);
+  }
+  if (retval > 0) {
+    idasls_mem->s_last_flag = IDASLS_JACFUNC_RECVR;
+    return (+1);
+  }
+
+  uint__t n = JacMat->NP;
+  uint__t nnz = JacMat->NNZ;
+  uint__t *ai = JacMat->indexvals;
+  uint__t *ap = JacMat->indexptrs;
+  real__t *ax = JacMat->data;
+  int num;
+
+  if (idasls_mem->s_first_factorize) {
+    /* ------------------------------------------------------------
+       Get the symbolic factorization
+       ------------------------------------------------------------*/
+    /* Update the ordering option with any user-updated values from
+       calls to IDANICSLUSetOrdering */
+    if (nicslu_data == NULL) {
+      IDAProcessError(IDA_mem, IDASLS_MEM_FAIL, "IDASLS", "IDANICSLUSetup",
+                      MSGSP_MEM_FAIL);
+      return (IDASLS_MEM_FAIL);
+    }
+
+    int ret;
+    switch (idasls_mem->sparsetype) {
+    case CSC_MAT:
+      ret = NicsLU_CreateMatrix(nicslu_data, n, nnz, ax, ai, ap);
+      if(ret != NICS_OK){
+      printf("Error in setup with CSC_MAT%d/n", ret);
+      printf("N : %d\t NNZ : %d\t ap[N] = %d\n", n, nnz, ap[n]);
+       }
+      nicslu_data->cfgi[0] = 1;
+      break;
+    case CSR_MAT:
+      ret = NicsLU_CreateMatrix(nicslu_data, n, nnz, ax, ai, ap);
+      if(ret != NICS_OK){
+      printf("Error in setup with CSR_MAT %d/n", ret);
+      printf("N : %d\t NNZ : %d\t ap[N] = %d\n", n, nnz, ap[n]);
+       }
+      nicslu_data->cfgi[0] = 0;
+      break;
+    default:
+      nicslu_data->cfgi[0] = 1;
+    }
+    ret = NicsLU_Analyze(nicslu_data);
+    // printf("%d returnValueOfNicsLUAnalyze\n", ret);
+    if(ret != NICS_OK){
+        printf("Error in setup, ret is %d for NicsLU_Analyze/n", ret);
+    }
+    char *numth = getenv("THREADS");
+    if (numth != NULL && atoi(numth) > 1) {
+      ret = NicsLU_CreateScheduler(nicslu_data);
+      //printf("suggestion: %s.\n", ret == 0 ? "parallel" : "sequential");
+      num = atoi(numth);
+      ret = NicsLU_CreateThreads(nicslu_data, num, TRUE);
+      ret = NicsLU_BindThreads(nicslu_data, FALSE);
+      performFactorization = &NicsLU_Factorize_MT;
+      performReFactorization = &NicsLU_ReFactorize_MT;
+      //if (ret == NICS_OK)
+      //  printf("%d threads created\n", num);
+    } else {
+      //printf("One thread created\n");
+      performFactorization = &NicsLU_Factorize;
+      performReFactorization = &NicsLU_ReFactorize;
+      num = 1;
+    }
+
+    if (ret != NICS_OK) {
+      IDAProcessError(IDA_mem, IDASLS_PACKAGE_FAIL, "IDASSLS", "IDANICSLUSetup",
+                      MSGSP_PACKAGE_FAIL);
+      return (IDASLS_PACKAGE_FAIL);
+    }
+
+    /* ------------------------------------------------------------
+      Compute the LU factorization of  the Jacobian.
+      ------------------------------------------------------------*/
+    performFactorization(nicslu_data);
+    idasls_mem->s_first_factorize = 0;
+  } else {
+    performReFactorization(nicslu_data, ax);
+
+    /*-----------------------------------------------------------
+      Check if a cheap estimate of the reciprocal of the condition
+      number is getting too small.  If so, delete
+      the prior numeric factorization and recompute it.
+      -----------------------------------------------------------*/
+    real__t cond;
+    real__t condb;
+    NicsLU_ConditionNumber(nicslu_data, &cond);
+    // printf("%e\n",cond);
+
+    /* Condition number may be getting large.
+    Compute more accurate estimate */
+   if(cond> TWOTHIRDS){
+      /* More accurate estimate also says condition number is
+         large, so recompute the numeric factorization */
+
+      // printf("Condition number too large, not using refactorization but factorization instead ... \n");
+      performFactorization(nicslu_data);
+  }
+  }
+  idasls_mem->s_last_flag = IDASLS_SUCCESS;
+
+  return (0);
+}
+
+static int IDANICSLUSolve(IDAMem IDA_mem, N_Vector b, N_Vector weight,
+                          N_Vector ycur, N_Vector ypcur, N_Vector rrcur) {
+  int flag;
+  realtype cjratio;
+  IDASlsMem idasls_mem;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+  realtype *bd;
+
+  idasls_mem = (IDASlsMem)IDA_mem->ida_lmem;
+  JacMat = idasls_mem->s_JacMat;
+  cjratio = IDA_mem->ida_cjratio;
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+  bd = N_VGetArrayPointer(b);
+
+  /* Call NICSLU to solve the linear system */
+  // NicsLU_Solve(nicslu_data, nicslu_data->ax);
+  NicsLU_Solve(nicslu_data, bd);
+
+  /* Scale the correction to account for change in cj. */
+  if (cjratio != ONE)
+    N_VScale(TWO / (ONE + cjratio), b, b);
+
+  idasls_mem->s_last_flag = IDASLS_SUCCESS;
+  return (IDASLS_SUCCESS);
+}
+
+static int IDANICSLUFree(IDAMem IDA_mem) {
+  IDASlsMem idasls_mem;
+  SNicsLU *nicslu_data;
+
+  idasls_mem = (IDASlsMem)IDA_mem->ida_lmem;
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+
+  NicsLU_Destroy(nicslu_data);
+  free(nicslu_data);
+  return (IDASLS_SUCCESS);
+}
+
+int IDANICSLUReInit(void *ida_mem_v, int n, int nnz, int reinit_type) {
+  IDAMem ida_mem;
+  IDASlsMem idasls_mem;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+
+  /* Return immediately if ida_mem is NULL. */
+  if (ida_mem_v == NULL) {
+    IDAProcessError(NULL, IDASLS_MEM_NULL, "IDASLS", "IDANICSLUReInit",
+                    MSGSP_IDAMEM_NULL);
+    return (IDASLS_MEM_NULL);
+  }
+  ida_mem = (IDAMem)ida_mem_v;
+
+  /* Return immediately if ark_lmem is NULL. */
+  if (ida_mem->ida_lmem == NULL) {
+    IDAProcessError(NULL, IDASLS_LMEM_NULL, "IDASLS", "IDANICSLUReInit",
+                    MSGSP_LMEM_NULL);
+    return (IDASLS_LMEM_NULL);
+  }
+
+  idasls_mem = (IDASlsMem)(ida_mem->ida_lmem);
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+
+  /* Return if reinit_type is not valid */
+  if ((reinit_type != 1) && (reinit_type != 2)) {
+    IDAProcessError(NULL, IDASLS_ILL_INPUT, "IDASLS", "IDANICSLUReInit",
+                    MSGSP_ILL_INPUT);
+    return (IDASLS_ILL_INPUT);
+  }
+
+  JacMat = idasls_mem->s_JacMat;
+
+  if (reinit_type == 1) {
+
+    /* Destroy previous Jacobian information */
+    if (idasls_mem->s_JacMat) {
+      SparseDestroyMat(idasls_mem->s_JacMat);
+    }
+
+    /* Allocate memory for the sparse Jacobian */
+    idasls_mem->s_JacMat = SparseNewMat(n, n, nnz, idasls_mem->sparsetype);
+    if (idasls_mem->s_JacMat == NULL) {
+      IDAProcessError(ida_mem, IDASLS_MEM_FAIL, "IDASLS", "IDANICSLU",
+                      MSGSP_MEM_FAIL);
+      return (IDASLS_MEM_FAIL);
+    }
+  }
+
+
+  //NicsLU_Destroy(idasls_mem->s_solver_data);
+  //free(idasls_mem->s_solver_data);
+  //idasls_mem->s_solver_data = (SNicsLU*)malloc(sizeof(SNicsLU));
+  //NicsLU_Initialize(idasls_mem->s_solver_data);
+  //JacMat = idasls_mem->s_JacMat;
+  //int ret = NicsLU_CreateMatrix(idasls_mem->s_solver_data, JacMat->NP, JacMat->NNZ, JacMat->data, JacMat->indexvals, JacMat->indexptrs);
+  //if(ret != NICS_OK)
+	//printf("Error in reinit %d/n", ret);
+  /* Free the prior factorazation and reset for first factorization */
+  idasls_mem->s_first_factorize = 1;
+
+  idasls_mem->s_last_flag = IDASLS_SUCCESS;
+
+  return (IDASLS_SUCCESS);
+}
diff --git a/sundials-2.7.0/src/idas/CMakeLists.txt b/sundials-2.7.0/src/idas/CMakeLists.txt
index 400a228..186845a 100644
--- a/sundials-2.7.0/src/idas/CMakeLists.txt
+++ b/sundials-2.7.0/src/idas/CMakeLists.txt
@@ -1,6 +1,6 @@
 # ---------------------------------------------------------------
-# $Revision: 4759 $
-# $Date: 2016-05-18 16:25:17 -0700 (Wed, 18 May 2016) $
+# $Revision: 4135 $
+# $Date: 2014-06-13 15:55:05 -0700 (Fri, 13 Jun 2014) $
 # ---------------------------------------------------------------
 # Programmer:  Radu Serban @ LLNL
 # ---------------------------------------------------------------
@@ -40,6 +40,10 @@ IF(KLU_FOUND)
     LIST(APPEND idas_SOURCES idas_klu.c)
 ENDIF()
 
+IF(NICSLU_FOUND)
+    LIST(APPEND idas_SOURCES idas_nicslu.c)
+ENDIF()
+
 IF(SUPERLUMT_FOUND)
     LIST(APPEND idas_SOURCES idas_superlumt.c)
 ENDIF()
@@ -80,6 +84,10 @@ IF(KLU_FOUND)
     LIST(APPEND idas_HEADERS idas_klu.h)
 ENDIF()
 
+IF(NICSLU_FOUND)
+    LIST(APPEND idas_HEADERS idas_nicslu.h)
+ENDIF()
+
 IF(SUPERLUMT_FOUND)
     LIST(APPEND idas_HEADERS idas_superlumt.h)
 ENDIF()
@@ -121,6 +129,8 @@ IF(BUILD_STATIC_LIBS)
   ADD_LIBRARY(sundials_idas_static STATIC 
     ${idas_SOURCES} ${idas_BL_SOURCES} ${idas_SLU_SOURCES}  ${shared_SOURCES})
 
+  TARGET_LINK_LIBRARIES(sundials_idas_static ${KLU_LIBRARIES} ${LAPACK_LIBRARIES})
+	
   # Set the library name and make sure it is not deleted
   SET_TARGET_PROPERTIES(sundials_idas_static
     PROPERTIES OUTPUT_NAME sundials_idas CLEAN_DIRECT_OUTPUT 1)
@@ -136,7 +146,9 @@ IF(BUILD_SHARED_LIBS)
   # Add the build target for the IDAS library
   ADD_LIBRARY(sundials_idas_shared SHARED 
     ${idas_SOURCES}  ${idas_BL_SOURCES} ${idas_SLU_SOURCES} ${shared_SOURCES})
-
+  
+  TARGET_LINK_LIBRARIES(sundials_idas_shared ${KLU_LIBRARIES} ${LAPACK_LIBRARIES} ${NICSLU_LIBRARIES})
+  
   # Set the library name and make sure it is not deleted
   SET_TARGET_PROPERTIES(sundials_idas_shared
     PROPERTIES OUTPUT_NAME sundials_idas CLEAN_DIRECT_OUTPUT 1)
diff --git a/sundials-2.7.0/src/idas/idas_nicslu.c b/sundials-2.7.0/src/idas/idas_nicslu.c
new file mode 100644
index 0000000..27a2973
--- /dev/null
+++ b/sundials-2.7.0/src/idas/idas_nicslu.c
@@ -0,0 +1,479 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "idas/idas_nicslu.h"
+#include "idas_impl.h"
+#include "idas_sparse_impl.h"
+#include "sundials/sundials_math.h"
+#include "sundials/sundials_nicslu_impl.h"
+
+static int IDANICSLUInit(IDAMem IDA_mem);
+
+static int IDANICSLUSetup(IDAMem IDA_mem, N_Vector yyp, N_Vector ypp,
+                          N_Vector rrp, N_Vector tmp1, N_Vector tmp2,
+                          N_Vector tmp3);
+
+static int IDANICSLUSolve(IDAMem IDA_mem, N_Vector b, N_Vector weight,
+                          N_Vector ycur, N_Vector ypcur, N_Vector rrcur);
+
+static int IDANICSLUFree(IDAMem IDA_mem);
+
+/* IDANICSLU lfreeB function */
+
+static void IDANICSLUFreeB(IDABMem IDAB_mem);
+
+#define ONE RCONST(1.0)
+#define TWO RCONST(2.0)
+#define TWOTHIRDS RCONST(0.6666666666666667)
+
+/*
+ * ------------------------------------------------------------------
+ * IDANICSLU interface functions
+ * ------------------------------------------------------------------
+ */
+
+static int IDANICSLUInit(IDAMem IDA_mem) {
+  IDASlsMem idasls_mem;
+
+  idasls_mem = (IDASlsMem)IDA_mem->ida_lmem;
+
+  idasls_mem->s_nje = 0;
+  idasls_mem->s_first_factorize = 1;
+
+  idasls_mem->s_last_flag = 0;
+  return (0);
+}
+
+static int IDANICSLUSetup(IDAMem IDA_mem, N_Vector yyp, N_Vector ypp,
+                          N_Vector rrp, N_Vector tmp1, N_Vector tmp2,
+                          N_Vector tmp3) {
+  static int count = 0;
+  int retval;
+  realtype tn, cj;
+  IDASlsMem idasls_mem;
+  IDASlsSparseJacFn jaceval;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+  void *jacdata;
+  static int (*performFactorization)(SNicsLU *) = NULL;
+  static int (*performReFactorization)(SNicsLU *, real__t *) = NULL;
+
+  realtype uround_twothirds;
+
+  uround_twothirds = SUNRpowerR(IDA_mem->ida_uround, TWOTHIRDS);
+
+  idasls_mem = (IDASlsMem)(IDA_mem->ida_lmem);
+  tn = IDA_mem->ida_tn;
+  cj = IDA_mem->ida_cj;
+
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+
+  jaceval = idasls_mem->s_jaceval;
+  jacdata = idasls_mem->s_jacdata;
+  JacMat = idasls_mem->s_JacMat;
+
+  /* Check that Jacobian eval routine is set */
+  if (jaceval == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_JAC_NOSET, "IDASSLS", "IDANICSLUSetup",
+                    MSGSP_JAC_NOSET);
+    free(idasls_mem);
+    idasls_mem = NULL;
+    return (IDASLS_JAC_NOSET);
+  }
+
+  /* Increment nje counter and call Jacobian eval routine. */
+  idasls_mem->s_nje++;
+  retval = jaceval(tn, cj, yyp, ypp, rrp, JacMat, jacdata, tmp1, tmp2, tmp3);
+
+  if (retval < 0) {
+    IDAProcessError(IDA_mem, IDASLS_JACFUNC_UNRECVR, "IDASSLS",
+                    "IDANICSLUSetup", MSGSP_JACFUNC_FAILED);
+    idasls_mem->s_last_flag = IDASLS_JACFUNC_UNRECVR;
+    return (IDASLS_JACFUNC_UNRECVR);
+  }
+  if (retval > 0) {
+    idasls_mem->s_last_flag = IDASLS_JACFUNC_RECVR;
+    return (+1);
+  }
+
+  uint__t n = JacMat->NP;
+  uint__t nnz = JacMat->NNZ;
+  uint__t *ai = JacMat->indexvals;
+  uint__t *ap = JacMat->indexptrs;
+  real__t *ax = JacMat->data;
+  int num;
+  int ret;
+  if (idasls_mem->s_first_factorize) {
+    /* ------------------------------------------------------------
+       Get the symbolic factorization
+       ------------------------------------------------------------*/
+
+    if (nicslu_data == NULL) {
+      IDAProcessError(IDA_mem, IDASLS_JAC_NOSET, "IDASSLS", "IDANICSLUSetup",
+                      MSGSP_JAC_NOSET);
+      return (+1);
+    }
+
+    ret = NicsLU_CreateMatrix(nicslu_data, n, nnz, ax, ai, ap);
+    if(ret != NICS_OK){
+        printf("Error in setup, ret is %d for NicsLU_CreateMatrix/n", ret);
+        printf("N : %d\t NNZ : %d\t ap[N] = %d\n", n, nnz, ap[n]);
+     }
+    switch(idasls_mem->sparsetype){
+    	case CSC_MAT: nicslu_data->cfgi[0] = 1;
+		      break;
+	case CSR_MAT: nicslu_data->cfgi[0] = 0;
+		      break;
+	default: nicslu_data->cfgi[0] = 1;
+    }
+
+    ret = NicsLU_Analyze(nicslu_data);
+    if(ret != NICS_OK){
+        printf("Error in setup, ret is %d for NicsLU_Analyze/n", ret);
+     }
+    char *numth = getenv("THREADS");
+    if (numth != NULL && atoi(numth) > 1) {
+      ret = NicsLU_CreateScheduler(nicslu_data);
+      printf("suggestion: %s.\n", ret == 0 ? "parallel" : "sequential");
+      num = atoi(numth);
+      ret = NicsLU_CreateThreads(nicslu_data, num, TRUE);
+      ret = NicsLU_BindThreads(nicslu_data, FALSE);
+      performFactorization = &NicsLU_Factorize_MT;
+      performReFactorization = &NicsLU_ReFactorize_MT;
+      if (ret == NICS_OK)
+        printf("%d threads created\n", num);
+    } else {
+      printf("One thread created\n");
+      performFactorization = &NicsLU_Factorize;
+      performReFactorization = &NicsLU_ReFactorize;
+      num = 1;
+    }
+
+    if (ret != NICS_OK) {
+      IDAProcessError(IDA_mem, IDASLS_PACKAGE_FAIL, "IDASSLS", "IDANICSLUSetup",
+                      MSGSP_PACKAGE_FAIL);
+      return (IDASLS_PACKAGE_FAIL);
+    }
+
+    /* ------------------------------------------------------------
+      Compute the LU factorization of  the Jacobian.
+      ------------------------------------------------------------*/
+    performFactorization(nicslu_data);
+    idasls_mem->s_first_factorize = 0;
+  } else {
+    performReFactorization(nicslu_data, ax);
+
+    /*-----------------------------------------------------------
+      Check if a cheap estimate of the reciprocal of the condition
+      number is getting too small.  If so, delete
+      the prior numeric factorization and recompute it.
+      -----------------------------------------------------------*/
+    real__t cond;
+    NicsLU_ConditionNumber(nicslu_data, &cond);
+
+    /* Condition number may be getting large.
+    Compute more accurate estimate */
+
+   //if(cond > (real__t) uround_twothirds){
+   if(cond> TWOTHIRDS){
+
+      /* More accurate estimate also says condition number is
+         large, so recompute the numeric factorization */
+
+       printf("Condition number too large, not using refactorization ... \n");
+      performFactorization(nicslu_data);
+    }
+  }
+
+  idasls_mem->s_last_flag = IDASLS_SUCCESS;
+  return (0);
+}
+
+static int IDANICSLUSolve(IDAMem IDA_mem, N_Vector b, N_Vector weight,
+                          N_Vector ycur, N_Vector ypcur, N_Vector rrcur) {
+  int flag;
+  realtype cjratio;
+  IDASlsMem idasls_mem;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+  realtype *bd;
+
+  idasls_mem = (IDASlsMem)IDA_mem->ida_lmem;
+  JacMat = idasls_mem->s_JacMat;
+  cjratio = IDA_mem->ida_cjratio;
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+  bd = N_VGetArrayPointer(b);
+
+  /* Call NICSLU to solve the linear system */
+  NicsLU_Solve(nicslu_data, bd);
+
+  /* Scale the correction to account for change in cj. */
+  if (cjratio != ONE)
+    N_VScale(TWO / (ONE + cjratio), b, b);
+
+  idasls_mem->s_last_flag = IDASLS_SUCCESS;
+  return (IDASLS_SUCCESS);
+}
+
+static int IDANICSLUFree(IDAMem IDA_mem) {
+  IDASlsMem idasls_mem;
+  SNicsLU *nicslu_data;
+
+  idasls_mem = (IDASlsMem)IDA_mem->ida_lmem;
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+
+  NicsLU_Destroy(nicslu_data);
+  free(nicslu_data);
+  return (IDASLS_SUCCESS);
+}
+
+int IDANICSLUB(void *ida_mem, int which, int n, int nnz,int sparsetype) {
+  IDAMem IDA_mem;
+  IDAadjMem IDAADJ_mem;
+  IDABMem IDAB_mem;
+  IDASlsMemB idaslsB_mem;
+  void *ida_memB;
+  int flag;
+
+  /* Is ida_mem alright? */
+  if (ida_mem == NULL) {
+    IDAProcessError(NULL, IDASLS_MEM_NULL, "IDASSLS", "IDANICSLUB",
+                    MSGSP_CAMEM_NULL);
+    return (IDASLS_MEM_NULL);
+  }
+  IDA_mem = (IDAMem)ida_mem;
+
+  /* Is ASA initialized? */
+  if (IDA_mem->ida_adjMallocDone == FALSE) {
+    IDAProcessError(IDA_mem, IDASLS_NO_ADJ, "IDASSLS", "IDANICSLUB",
+                    MSGSP_NO_ADJ);
+    return (IDASLS_NO_ADJ);
+  }
+  IDAADJ_mem = IDA_mem->ida_adj_mem;
+
+  /* Check the value of which */
+  if (which >= IDAADJ_mem->ia_nbckpbs) {
+    IDAProcessError(IDA_mem, IDASLS_ILL_INPUT, "IDASSLS", "IDANICSLUB",
+                    MSGSP_BAD_WHICH);
+    return (IDASLS_ILL_INPUT);
+  }
+
+  /* Find the IDABMem entry in the linked list corresponding to 'which'. */
+  IDAB_mem = IDAADJ_mem->IDAB_mem;
+  while (IDAB_mem != NULL) {
+    if (which == IDAB_mem->ida_index)
+      break;
+    /* advance */
+    IDAB_mem = IDAB_mem->ida_next;
+  }
+
+  /* Alloc memory for IDASlsMemRecB */
+  idaslsB_mem = (IDASlsMemB)malloc(sizeof(struct IDASlsMemRecB));
+  if (idaslsB_mem == NULL) {
+    IDAProcessError(IDAB_mem->IDA_mem, IDASLS_MEM_FAIL, "IDASSLS", "IDANICSLUB",
+                    MSGSP_MEM_FAIL);
+    return (IDASLS_MEM_FAIL);
+  }
+
+  /* set matrix type and initialize Jacob function. */
+  idaslsB_mem->s_djacB = NULL;
+
+  /* Attach lmemB data and lfreeB function. */
+  IDAB_mem->ida_lmem = idaslsB_mem;
+  IDAB_mem->ida_lfree = IDANICSLUFreeB;
+
+  /* Call IDANICSLU to the IDAS data of the backward problem. */
+  ida_memB = (void *)IDAB_mem->IDA_mem;
+  flag = IDANICSLU(ida_memB, n, nnz,sparsetype);
+
+  if (flag != IDASLS_SUCCESS) {
+    free(idaslsB_mem);
+    idaslsB_mem = NULL;
+  }
+
+  return (flag);
+}
+
+int IDANICSLUReInit(void *ida_mem_v, int n, int nnz, int reinit_type) {
+  IDAMem ida_mem;
+  IDASlsMem idasls_mem;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+
+  /* Return immediately if ida_mem is NULL. */
+  if (ida_mem_v == NULL) {
+    IDAProcessError(NULL, IDASLS_MEM_NULL, "IDASSLS", "IDANICSLUReInit",
+                    MSGSP_IDAMEM_NULL);
+    return (IDASLS_MEM_NULL);
+  }
+  ida_mem = (IDAMem)ida_mem_v;
+
+  /* Return immediately if ark_lmem is NULL. */
+  if (ida_mem->ida_lmem == NULL) {
+    IDAProcessError(NULL, IDASLS_LMEM_NULL, "IDASSLS", "IDANICSLUReInit",
+                    MSGSP_LMEM_NULL);
+    return (IDASLS_LMEM_NULL);
+  }
+
+  idasls_mem = (IDASlsMem)(ida_mem->ida_lmem);
+  nicslu_data = (SNicsLU *)idasls_mem->s_solver_data;
+
+  /* Return if reinit_type is not valid */
+  if ((reinit_type != 1) && (reinit_type != 2)) {
+    IDAProcessError(NULL, IDASLS_ILL_INPUT, "IDASSLS", "IDANICSLUReInit",
+                    MSGSP_ILL_INPUT);
+    return (IDASLS_ILL_INPUT);
+  }
+
+  JacMat = idasls_mem->s_JacMat;
+
+  if (reinit_type == 1) {
+
+    /* Destroy previous Jacobian information */
+    if (idasls_mem->s_JacMat) {
+      SparseDestroyMat(idasls_mem->s_JacMat);
+    }
+
+    /* Allocate memory for the sparse Jacobian */
+    idasls_mem->s_JacMat = SparseNewMat(n, n, nnz, idasls_mem->sparsetype);
+    if (idasls_mem->s_JacMat == NULL) {
+      IDAProcessError(ida_mem, IDASLS_MEM_FAIL, "IDASSLS", "IDANICSLU",
+                      MSGSP_MEM_FAIL);
+      return (IDASLS_MEM_FAIL);
+    }
+  }
+
+  free(idasls_mem->s_solver_data);
+  idasls_mem->s_solver_data = (SNicsLU*)malloc(sizeof(SNicsLU));
+  NicsLU_Initialize(idasls_mem->s_solver_data);
+  /* Free the prior factorazation and reset for first factorization */
+   idasls_mem->s_first_factorize = 1;
+
+  idasls_mem->s_last_flag = IDASLS_SUCCESS;
+
+  return (0);
+}
+
+int IDANICSLU(void *ida_mem, int n, int nnz, int sparsetype) {
+  IDAMem IDA_mem;
+  IDASlsMem idasls_mem;
+  int flag;
+
+  if (ida_mem == NULL) {
+    IDAProcessError(NULL, IDASLS_MEM_NULL, "IDASSLS", "IDANICSLU",
+                    MSGSP_IDAMEM_NULL);
+    return (IDASLS_MEM_NULL);
+  }
+
+  IDA_mem = (IDAMem)ida_mem;
+
+  /* Test if the NVECTOR package is compatible with the Direct solver */
+  if (IDA_mem->ida_tempv1->ops->nvgetarraypointer == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_ILL_INPUT, "IDASSLS", "IDANICLSU",
+                    MSGSP_BAD_NVECTOR);
+    return (IDASLS_ILL_INPUT);
+  }
+
+  if (IDA_mem->ida_lfree != NULL)
+    flag = IDA_mem->ida_lfree(IDA_mem);
+
+  /* Set five main function fields in IDA_mem. */
+  IDA_mem->ida_linit = IDANICSLUInit;
+  IDA_mem->ida_lsetup = IDANICSLUSetup;
+  IDA_mem->ida_lsolve = IDANICSLUSolve;
+  IDA_mem->ida_lperf = NULL;
+  IDA_mem->ida_lfree = IDANICSLUFree;
+
+  idasls_mem = (IDASlsMem)malloc(sizeof(struct IDASlsMemRec));
+  if (idasls_mem == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_MEM_FAIL, "IDASSLS", "IDANICSLU",
+                    MSGSP_MEM_FAIL);
+    return (IDASLS_MEM_FAIL);
+  }
+
+  idasls_mem->s_solver_data = (SNicsLU *)malloc(sizeof(SNicsLU));
+  NicsLU_Initialize(idasls_mem->s_solver_data);
+  SNicsLU* nicslu_data = idasls_mem->s_solver_data;
+
+  if(nicslu_data == NULL){
+     IDAProcessError(IDA_mem, IDASLS_MEM_FAIL, "IDASSLS", "IDANICSLU",
+                    MSGSP_MEM_FAIL);
+    return (IDASLS_MEM_FAIL); 	
+  }
+
+  IDA_mem->ida_setupNonNull = TRUE;
+
+  /* Set default Jacobian routine and Jacobian data */
+  idasls_mem->s_jaceval = NULL;
+  idasls_mem->s_jacdata = IDA_mem->ida_user_data;
+  idasls_mem->sparsetype = sparsetype;
+
+  /* Allocate memory for the sparse Jacobian */
+  idasls_mem->s_JacMat = SparseNewMat(n, n, nnz, sparsetype);
+  if (idasls_mem->s_JacMat == NULL) {
+    IDAProcessError(IDA_mem, IDASLS_MEM_FAIL, "IDASSLS", "IDANICSLU",
+                    MSGSP_MEM_FAIL);
+    return (IDASLS_MEM_FAIL);
+  }
+
+  
+  IDA_mem->ida_lmem = idasls_mem;
+
+  return (IDASLS_SUCCESS);
+}
+
+int IDANICSLUReInitB(void *ida_mem, int which, int n, int nnz,
+                     int reinit_type) {
+  IDAMem IDA_mem;
+  IDAadjMem IDAADJ_mem;
+  IDABMem IDAB_mem;
+  IDASlsMemB idaslsB_mem;
+  void *ida_memB;
+  int flag;
+
+  /* Is ida_mem allright? */
+  if (ida_mem == NULL) {
+    IDAProcessError(NULL, IDASLS_MEM_NULL, "IDASSLS", "IDANICSLUReInitB",
+                    MSGSP_CAMEM_NULL);
+    return (IDASLS_MEM_NULL);
+  }
+  IDA_mem = (IDAMem)ida_mem;
+
+  /* Is ASA initialized? */
+  if (IDA_mem->ida_adjMallocDone == FALSE) {
+    IDAProcessError(IDA_mem, IDASLS_NO_ADJ, "IDASSLS", "IDANICSLUReInitB",
+                    MSGSP_NO_ADJ);
+    return (IDASLS_NO_ADJ);
+  }
+  IDAADJ_mem = IDA_mem->ida_adj_mem;
+
+  /* Check the value of which */
+  if (which >= IDAADJ_mem->ia_nbckpbs) {
+    IDAProcessError(IDA_mem, IDASLS_ILL_INPUT, "IDASSLS", "IDANICSLUReInitB",
+                    MSGSP_BAD_WHICH);
+    return (IDASLS_ILL_INPUT);
+  }
+
+  /* Find the IDABMem entry in the linked list corresponding to 'which'. */
+  IDAB_mem = IDAADJ_mem->IDAB_mem;
+  while (IDAB_mem != NULL) {
+    if (which == IDAB_mem->ida_index)
+      break;
+    /* advance */
+    IDAB_mem = IDAB_mem->ida_next;
+  }
+
+  ida_memB = (void *)(IDAB_mem->IDA_mem);
+
+  flag = IDANICSLUReInit(ida_memB, n, nnz, reinit_type);
+
+  return (flag);
+}
+
+static void IDANICSLUFreeB(IDABMem IDAB_mem) {
+  IDASlsMemB idaslsB_mem;
+
+  idaslsB_mem = (IDASlsMemB)IDAB_mem->ida_lmem;
+
+  free(idaslsB_mem);
+}
diff --git a/sundials-2.7.0/src/kinsol/CMakeLists.txt b/sundials-2.7.0/src/kinsol/CMakeLists.txt
index d22ed62..b5abf23 100644
--- a/sundials-2.7.0/src/kinsol/CMakeLists.txt
+++ b/sundials-2.7.0/src/kinsol/CMakeLists.txt
@@ -42,6 +42,10 @@ IF(SUPERLUMT_FOUND)
     LIST(APPEND kinsol_SOURCES kinsol_superlumt.c)
 ENDIF()
 
+IF(NICSLU_FOUND)
+    LIST(APPEND kinsol_SOURCES kinsol_nicslu.c)
+ENDIF()
+
 # Add variable shared_SOURCES with the common SUNDIALS sources which will
 # also be included in the KINSOL library
 SET(shared_SOURCES
@@ -79,6 +83,10 @@ IF(KLU_FOUND)
     LIST(APPEND kinsol_HEADERS kinsol_klu.h kinsol_sparse.h)
 ENDIF()
 
+IF(NICSLU_FOUND)
+    LIST(APPEND kinsol_HEADERS kinsol_nicslu.h kinsol_sparse.h)
+ENDIF()
+
 IF(SUPERLUMT_FOUND)
     LIST(APPEND kinsol_HEADERS kinsol_superlumt.h kinsol_sparse.h)
 ENDIF()
@@ -114,6 +122,15 @@ ELSE(KLU_FOUND)
   SET(kinsol_KLU_HEADERS "")
 ENDIF(KLU_FOUND)
 
+IF(NICSLU_FOUND)
+  SET(kinsol_NICSLU_SOURCES kinsol_nicslu.c)
+  SET(kinsol_NICSLU_HEADERS kinsol_nicslu.h)
+  ADD_PREFIX(${sundials_SOURCE_DIR}/include/kinsol/ kinsol_NICSLU_HEADERS)
+ELSE(NICSLU_FOUND)
+  SET(kinsol_NICSLU_SOURCES "")
+  SET(kinsol_NICSLU_HEADERS "")
+ENDIF(NICSLU_FOUND)
+
 # Add source directories to include directories for access to
 # implementation only header files.
 INCLUDE_DIRECTORIES(.)
@@ -127,7 +144,7 @@ IF(BUILD_STATIC_LIBS)
 
   # Add the build target for the static KINSOL library
   ADD_LIBRARY(sundials_kinsol_static STATIC
-    ${kinsol_SOURCES} ${kinsol_BL_SOURCES} ${kinsol_SLU_SOURCES} ${kinsol_KLU_SOURCES} ${shared_SOURCES})
+    ${kinsol_SOURCES} ${kinsol_BL_SOURCES} ${kinsol_SLU_SOURCES} ${kinsol_KLU_SOURCES} ${kinsol_NICSLU_SOURCES} ${shared_SOURCES})
 
   # Set the library name and make sure it is not deleted
   SET_TARGET_PROPERTIES(sundials_kinsol_static
@@ -143,7 +160,7 @@ IF(BUILD_SHARED_LIBS)
 
   # Add the build target for the KINSOL library
   ADD_LIBRARY(sundials_kinsol_shared SHARED
-    ${kinsol_SOURCES} ${kinsol_BL_SOURCES} ${kinsol_SLU_SOURCES} ${kinsol_KLU_SOURCES} ${shared_SOURCES})
+    ${kinsol_SOURCES} ${kinsol_BL_SOURCES} ${kinsol_SLU_SOURCES} ${kinsol_KLU_SOURCES} ${kinsol_NICSLU_SOURCES} ${shared_SOURCES})
 
   # Set the library name and make sure it is not deleted
   SET_TARGET_PROPERTIES(sundials_kinsol_shared
@@ -159,7 +176,7 @@ IF(BUILD_SHARED_LIBS)
 ENDIF(BUILD_SHARED_LIBS)
 
 # Install the KINSOL header files
-INSTALL(FILES ${kinsol_HEADERS} ${kinsol_BL_HEADERS} ${kinsol_SLU_HEADERS} ${kinsol_KLU_HEADERS} DESTINATION include/kinsol)
+INSTALL(FILES ${kinsol_HEADERS} ${kinsol_BL_HEADERS} ${kinsol_SLU_HEADERS} ${kinsol_KLU_HEADERS} ${kinsol_NICSLU_HEADERS} DESTINATION include/kinsol)
 
 # Install the KINSOL implementation header file
 INSTALL(FILES kinsol_impl.h DESTINATION include/kinsol)
diff --git a/sundials-2.7.0/src/kinsol/kinsol.c b/sundials-2.7.0/src/kinsol/kinsol.c
index 72903fc..80d8078 100644
--- a/sundials-2.7.0/src/kinsol/kinsol.c
+++ b/sundials-2.7.0/src/kinsol/kinsol.c
@@ -8,8 +8,8 @@
  * -----------------------------------------------------------------
  * LLNS Copyright Start
  * Copyright (c) 2014, Lawrence Livermore National Security
- * This work was performed under the auspices of the U.S. Department 
- * of Energy by Lawrence Livermore National Laboratory in part under 
+ * This work was performed under the auspices of the U.S. Department
+ * of Energy by Lawrence Livermore National Laboratory in part under
  * Contract W-7405-Eng-48 and in part under Contract DE-AC52-07NA27344.
  * Produced at the Lawrence Livermore National Laboratory.
  * All rights reserved.
@@ -60,7 +60,7 @@
  * -----------------------------------------------------------------
  */
 
-/* 
+/*
  * =================================================================
  * IMPORTED HEADER FILES
  * =================================================================
@@ -77,7 +77,7 @@
 #include "kinsol_spils_impl.h"
 #include <sundials/sundials_math.h>
 
-/* 
+/*
  * =================================================================
  * MACRO DEFINITIONS
  * =================================================================
@@ -86,7 +86,7 @@
 /* Macro: loop */
 #define loop for(;;)
 
-/* 
+/*
  * =================================================================
  * KINSOL PRIVATE CONSTANTS
  * =================================================================
@@ -109,14 +109,14 @@
 #define POINT9    RCONST(0.9)
 #define POINT0001 RCONST(0.0001)
 
-/* 
+/*
  * =================================================================
  * KINSOL ROUTINE-SPECIFIC CONSTANTS
  * =================================================================
  */
 
-/* 
- * Control constants for lower-level functions used by KINSol 
+/*
+ * Control constants for lower-level functions used by KINSol
  * ----------------------------------------------------------
  *
  * KINStop return value requesting more iterations
@@ -165,7 +165,7 @@
 #define PRNT_ALPHABETA 11
 #define PRNT_ADJ       12
 
-/* 
+/*
  * =================================================================
  * PRIVATE FUNCTION PROTOTYPES
  * =================================================================
@@ -178,32 +178,32 @@ static int KINConstraint(KINMem kin_mem );
 static void KINForcingTerm(KINMem kin_mem, realtype fnormp);
 static void KINFreeVectors(KINMem kin_mem);
 
-static int  KINFullNewton(KINMem kin_mem, realtype *fnormp, 
+static int  KINFullNewton(KINMem kin_mem, realtype *fnormp,
                           realtype *f1normp, booleantype *maxStepTaken);
-static int  KINLineSearch(KINMem kin_mem, realtype *fnormp, 
+static int  KINLineSearch(KINMem kin_mem, realtype *fnormp,
                           realtype *f1normp, booleantype *maxStepTaken);
-static int  KINPicardAA(KINMem kin_mem, long int *iter, realtype *R, 
+static int  KINPicardAA(KINMem kin_mem, long int *iter, realtype *R,
 			realtype *gamma, realtype *fmax);
-static int  KINFP(KINMem kin_mem, long int *iter, realtype *R, 
+static int  KINFP(KINMem kin_mem, long int *iter, realtype *R,
 		  realtype *gamma, realtype *fmax);
 
 static int  KINLinSolDrv(KINMem kinmem);
-static int  KINPicardFcnEval(KINMem kin_mem, N_Vector gval, N_Vector uval, 
+static int  KINPicardFcnEval(KINMem kin_mem, N_Vector gval, N_Vector uval,
 			     N_Vector fval1);
 static realtype KINScFNorm(KINMem kin_mem, N_Vector v, N_Vector scale);
 static realtype KINScSNorm(KINMem kin_mem, N_Vector v, N_Vector u);
-static int KINStop(KINMem kin_mem, booleantype maxStepTaken, 
+static int KINStop(KINMem kin_mem, booleantype maxStepTaken,
 		   int sflag);
-static int AndersonAcc(KINMem kin_mem, N_Vector gval, N_Vector fv, N_Vector x, 
+static int AndersonAcc(KINMem kin_mem, N_Vector gval, N_Vector fv, N_Vector x,
 		       N_Vector x_old, int iter, realtype *R, realtype *gamma);
 
-/* 
+/*
  * =================================================================
  * EXPORTED FUNCTIONS IMPLEMENTATION
  * =================================================================
  */
 
-/* 
+/*
  * -----------------------------------------------------------------
  * Creation and allocation functions
  * -----------------------------------------------------------------
@@ -212,18 +212,18 @@ static int AndersonAcc(KINMem kin_mem, N_Vector gval, N_Vector fv, N_Vector x,
 /*
  * Function : KINCreate
  *
- * KINCreate creates an internal memory block for a problem to 
+ * KINCreate creates an internal memory block for a problem to
  * be solved by KINSOL. If successful, KINCreate returns a pointer
  * to the problem memory. This pointer should be passed to
  * KINInit. If an initialization error occurs, KINCreate prints
- * an error message to standard error and returns NULL. 
+ * an error message to standard error and returns NULL.
  */
 
 void *KINCreate(void)
 {
   KINMem kin_mem;
   realtype uround;
- 
+
   kin_mem = NULL;
   kin_mem = (KINMem) malloc(sizeof(struct KINMemRec));
   if (kin_mem == NULL) {
@@ -237,7 +237,7 @@ void *KINCreate(void)
   /* set uround (unit roundoff) */
 
   kin_mem->kin_uround = uround = UNIT_ROUNDOFF;
-  
+
   /* set default values for solver optional inputs */
 
   kin_mem->kin_func             = NULL;
@@ -307,7 +307,7 @@ void *KINCreate(void)
 /*
  * Function : KINInit
  *
- * KINInit allocates memory for a problem or execution of KINSol. 
+ * KINInit allocates memory for a problem or execution of KINSol.
  * If memory is successfully allocated, KIN_SUCCESS is returned.
  * Otherwise, an error message is printed and an error flag
  * returned.
@@ -318,7 +318,7 @@ int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl)
   long int liw1, lrw1;
   KINMem kin_mem;
   booleantype allocOK, nvectorOK;
-  
+
   /* check kinmem */
 
   if (kinmem == NULL) {
@@ -372,7 +372,7 @@ int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl)
   kin_mem->kin_lsolve = NULL;
   kin_mem->kin_lfree  = NULL;
   kin_mem->kin_lmem   = NULL;
-  
+
   /* problem memory has been successfully allocated */
 
   kin_mem->kin_MallocDone = TRUE;
@@ -409,7 +409,7 @@ int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl)
 #define uround           (kin_mem->kin_uround)
 #define nni              (kin_mem->kin_nni)
 #define nfe              (kin_mem->kin_nfe)
-#define nbcf             (kin_mem->kin_nbcf)  
+#define nbcf             (kin_mem->kin_nbcf)
 #define nbktrk           (kin_mem->kin_nbktrk)
 #define ncscmx           (kin_mem->kin_ncscmx)
 #define stepl            (kin_mem->kin_stepl)
@@ -417,15 +417,15 @@ int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl)
 #define sthrsh           (kin_mem->kin_sthrsh)
 #define linit            (kin_mem->kin_linit)
 #define lsetup           (kin_mem->kin_lsetup)
-#define lsolve           (kin_mem->kin_lsolve) 
+#define lsolve           (kin_mem->kin_lsolve)
 #define lfree            (kin_mem->kin_lfree)
-#define constraintsSet   (kin_mem->kin_constraintsSet) 
-#define jacCurrent       (kin_mem->kin_jacCurrent)          
+#define constraintsSet   (kin_mem->kin_constraintsSet)
+#define jacCurrent       (kin_mem->kin_jacCurrent)
 #define nnilset          (kin_mem->kin_nnilset)
-#define lmem             (kin_mem->kin_lmem)        
+#define lmem             (kin_mem->kin_lmem)
 #define inexact_ls       (kin_mem->kin_inexact_ls)
 #define setupNonNull     (kin_mem->kin_setupNonNull)
-#define fval             (kin_mem->kin_fval)      
+#define fval             (kin_mem->kin_fval)
 #define fnorm            (kin_mem->kin_fnorm)
 #define f1norm           (kin_mem->kin_f1norm)
 #define etaflag          (kin_mem->kin_etaflag)
@@ -463,7 +463,7 @@ int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl)
 #define setstop          (kin_mem->kin_setstop_aa)
 #define strategy         (kin_mem->kin_globalstrategy)
 
-/* 
+/*
  * -----------------------------------------------------------------
  * Main solver function
  * -----------------------------------------------------------------
@@ -476,7 +476,7 @@ int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl)
  * process of computing an approximate solution of the nonlinear
  * system F(uu) = 0. The KINSol routine calls the following
  * subroutines:
- *
+ *fval
  *  KINSolInit    checks if initial guess satisfies user-supplied
  *                constraints and initializes linear solver
  *
@@ -491,7 +491,7 @@ int KINInit(void *kinmem, KINSysFn func, N_Vector tmpl)
  *  KINStop  determines if an approximate solution has been found
  */
 
-int KINSol(void *kinmem, N_Vector u, int strategy_in,  
+int KINSol(void *kinmem, N_Vector u, int strategy_in,
            N_Vector u_scale, N_Vector f_scale)
 {
   realtype fnormp, f1normp, epsmin, fmax=ZERO;
@@ -517,7 +517,7 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
   kin_mem = (KINMem) kinmem;
 
   if(kin_mem->kin_MallocDone == FALSE) {
-    KINProcessError(NULL, KIN_NO_MALLOC, "KINSOL", "KINSol", MSG_NO_MALLOC);    
+    KINProcessError(NULL, KIN_NO_MALLOC, "KINSOL", "KINSol", MSG_NO_MALLOC);
     return(KIN_NO_MALLOC);
   }
 
@@ -528,7 +528,7 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
   fscale = f_scale;
   strategy = strategy_in;
 
-  /* CSW:  
+  /* CSW:
      Call fixed point solver if requested.  Note that this should probably
      be forked off to a FPSOL solver instead of kinsol in the future. */
   if ( strategy == KIN_FP ) {
@@ -583,11 +583,11 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
      current function norm. */
   if (omega == ZERO) eval_omega = TRUE;
   else               eval_omega = FALSE;
- 
 
-  /* CSW:  
-     Call fixed point solver for Picard method if requested.  
-     Note that this should probably be forked off to a part of an 
+
+  /* CSW:
+     Call fixed point solver for Picard method if requested.
+     Note that this should probably be forked off to a part of an
      FPSOL solver instead of kinsol in the future. */
   if ( strategy == KIN_PICARD ) {
 
@@ -623,7 +623,7 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
 
       /* Full Newton Step*/
 
-      /* call KINLinSolDrv to calculate the (approximate) Newton step, pp */ 
+      /* call KINLinSolDrv to calculate the (approximate) Newton step, pp */
       ret = KINLinSolDrv(kin_mem);
       if (ret != KIN_SUCCESS) break;
 
@@ -639,7 +639,7 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
 
       /* Line Search */
 
-      /* call KINLinSolDrv to calculate the (approximate) Newton step, pp */ 
+      /* call KINLinSolDrv to calculate the (approximate) Newton step, pp */
       ret = KINLinSolDrv(kin_mem);
       if (ret != KIN_SUCCESS) break;
 
@@ -660,14 +660,14 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
     }
 
     if ( (strategy != KIN_PICARD) && (strategy != KIN_FP) ) {
-      
+
       /* evaluate eta by calling the forcing term routine */
       if (callForcingTerm) KINForcingTerm(kin_mem, fnormp);
 
       fnorm = fnormp;
 
       /* call KINStop to check if tolerances where met by this iteration */
-      ret = KINStop(kin_mem, maxStepTaken, sflag); 
+      ret = KINStop(kin_mem, maxStepTaken, sflag);
 
       if (ret == RETRY_ITERATION) {
 	retry_nni = TRUE;
@@ -685,10 +685,10 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
     if (printfl>0)
       KINPrintInfo(kin_mem, PRNT_NNI, "KINSOL", "KINSol", INFO_NNI, nni, nfe, fnorm);
 
-    if (ret != CONTINUE_ITERATIONS) break; 
+    if (ret != CONTINUE_ITERATIONS) break;
 
     fflush(errfp);
-    
+
   }  /* end of loop; return */
 
 
@@ -725,11 +725,11 @@ int KINSol(void *kinmem, N_Vector u, int strategy_in,
     KINProcessError(kin_mem, KIN_MXNEWT_5X_EXCEEDED, "KINSOL", "KINSol", MSG_MXNEWT_5X_EXCEEDED);
     break;
   }
-  
+
   return(ret);
 }
 
-/* 
+/*
  * -----------------------------------------------------------------
  * Deallocation function
  * -----------------------------------------------------------------
@@ -761,7 +761,7 @@ void KINFree(void **kinmem)
   *kinmem = NULL;
 }
 
-/* 
+/*
  * =================================================================
  * PRIVATE FUNCTIONS
  * =================================================================
@@ -792,7 +792,7 @@ static booleantype KINCheckNvector(N_Vector tmpl)
   else return(TRUE);
 }
 
-/* 
+/*
  * -----------------------------------------------------------------
  * Memory allocation/deallocation
  * -----------------------------------------------------------------
@@ -809,9 +809,9 @@ static booleantype KINCheckNvector(N_Vector tmpl)
 
 static booleantype KINAllocVectors(KINMem kin_mem, N_Vector tmpl)
 {
-  /* allocate unew, fval, pp, vtemp1 and vtemp2. */  
+  /* allocate unew, fval, pp, vtemp1 and vtemp2. */
   /* allocate df, dg, q, for Anderson Acceleration, Broyden and EN */
- 
+
   unew = N_VClone(tmpl);
   if (unew == NULL) return(FALSE);
 
@@ -884,7 +884,7 @@ static booleantype KINAllocVectors(KINMem kin_mem, N_Vector tmpl)
       free(kin_mem->kin_gamma_aa);
       return(KIN_MEM_FAIL);
     }
-  } 
+  }
 
   if (maa) {
     fold = N_VClone(tmpl);
@@ -983,7 +983,7 @@ static void KINFreeVectors(KINMem kin_mem)
   if (vtemp1 != NULL) N_VDestroy(vtemp1);
   if (vtemp2 != NULL) N_VDestroy(vtemp2);
 
-  if ( (kin_mem->kin_globalstrategy == KIN_PICARD) && (kin_mem->kin_gval != NULL) ) 
+  if ( (kin_mem->kin_globalstrategy == KIN_PICARD) && (kin_mem->kin_gval != NULL) )
     N_VDestroy(kin_mem->kin_gval);
 
   if ( ((strategy == KIN_PICARD) || (strategy == KIN_FP)) && (maa > 0) ) {
@@ -1020,7 +1020,7 @@ static void KINFreeVectors(KINMem kin_mem)
   return;
 }
 
-/* 
+/*
  * -----------------------------------------------------------------
  * Initial setup
  * -----------------------------------------------------------------
@@ -1049,7 +1049,7 @@ static int KINSolInit(KINMem kin_mem)
 {
   int retval;
   realtype fmax;
-  
+
   /* check for illegal input parameters */
 
   if (uu == NULL) {
@@ -1057,7 +1057,7 @@ static int KINSolInit(KINMem kin_mem)
     return(KIN_ILL_INPUT);
   }
 
-  if ( (strategy != KIN_NONE) && (strategy != KIN_LINESEARCH) && 
+  if ( (strategy != KIN_NONE) && (strategy != KIN_LINESEARCH) &&
        (strategy != KIN_PICARD) && (strategy != KIN_FP) ) {
     KINProcessError(kin_mem, KIN_ILL_INPUT, "KINSOL", "KINSolInit", MSG_BAD_GLSTRAT);
     return(KIN_ILL_INPUT);
@@ -1087,11 +1087,11 @@ static int KINSolInit(KINMem kin_mem)
     KINProcessError(kin_mem, KIN_ILL_INPUT, "KINSOL", "KINSolInit", MSG_CONSTRAINTS_NOTOK);
     return(KIN_ILL_INPUT);
   }
-    
+
 
   /* set the constraints flag */
 
-  if (constraints == NULL) 
+  if (constraints == NULL)
     constraintsSet = FALSE;
   else {
     constraintsSet = TRUE;
@@ -1110,7 +1110,7 @@ static int KINSolInit(KINMem kin_mem)
       return(KIN_ILL_INPUT);
     }
   }
-  
+
   /* all error checking is complete at this point */
 
   if (printfl > 0)
@@ -1135,7 +1135,7 @@ static int KINSolInit(KINMem kin_mem)
 
     if (etaflag == KIN_ETACHOICE1) ealpha = (ONE + SUNRsqrt(FIVE)) * HALF;
 
-    /* initial value for eta set to 0.5 for other than the 
+    /* initial value for eta set to 0.5 for other than the
        KIN_ETACONSTANT option */
 
     if (etaflag != KIN_ETACONSTANT) eta = HALF;
@@ -1158,11 +1158,11 @@ static int KINSolInit(KINMem kin_mem)
   retval = func(uu, fval, user_data); nfe++;
 
   if (retval < 0) {
-    KINProcessError(kin_mem, KIN_SYSFUNC_FAIL, "KINSOL", "KINSolInit", 
+    KINProcessError(kin_mem, KIN_SYSFUNC_FAIL, "KINSOL", "KINSolInit",
 		    MSG_SYSFUNC_FAILED);
     return(KIN_SYSFUNC_FAIL);
   } else if (retval > 0) {
-    KINProcessError(kin_mem, KIN_FIRST_SYSFUNC_ERR, "KINSOL", "KINSolInit", 
+    KINProcessError(kin_mem, KIN_FIRST_SYSFUNC_ERR, "KINSOL", "KINSolInit",
 		    MSG_SYSFUNC_FIRST);
     return(KIN_FIRST_SYSFUNC_ERR);
   }
@@ -1175,7 +1175,7 @@ static int KINSolInit(KINMem kin_mem)
 
   if (printfl > 1)
     KINPrintInfo(kin_mem, PRNT_FMAX, "KINSOL", "KINSolInit", INFO_FMAX, fmax);
-  
+
   /* initialize the linear solver if linit != NULL */
 
   if (linit != NULL) {
@@ -1193,7 +1193,7 @@ static int KINSolInit(KINMem kin_mem)
   fnorm_sub = fnorm;
 
   if (printfl > 0)
-    KINPrintInfo(kin_mem, PRNT_NNI, "KINSOL", "KINSolInit", 
+    KINPrintInfo(kin_mem, PRNT_NNI, "KINSOL", "KINSolInit",
 		 INFO_NNI, nni, nfe, fnorm);
 
   /* problem has now been successfully initialized */
@@ -1201,7 +1201,7 @@ static int KINSolInit(KINMem kin_mem)
   return(KIN_SUCCESS);
 }
 
-/* 
+/*
  * -----------------------------------------------------------------
  * Step functions
  * -----------------------------------------------------------------
@@ -1213,7 +1213,7 @@ static int KINSolInit(KINMem kin_mem)
  * This routine handles the process of solving for the approximate
  * solution of the Newton equations in the Newton iteration.
  * Subsequent routines handle the nonlinear aspects of its
- * application. 
+ * application.
  */
 
 static int KINLinSolDrv(KINMem kin_mem)
@@ -1255,7 +1255,7 @@ static int KINLinSolDrv(KINMem kin_mem)
     else if (retval < 0)                      return(KIN_LSOLVE_FAIL);
     else if ((!setupNonNull) || (jacCurrent)) return(KIN_LINSOLV_NO_RECOVERY);
 
-    /* loop back only if the linear solver setup is in use 
+    /* loop back only if the linear solver setup is in use
        and Jacobian information is not current */
 
     sthrsh = TWO;
@@ -1270,7 +1270,7 @@ static int KINLinSolDrv(KINMem kin_mem)
  * algorithm. Its purpose is to compute unew = uu + pp in the
  * direction pp from uu, taking the full Newton step. The
  * step may be constrained if the constraint conditions are
- * violated, or if the norm of pp is greater than mxnewtstep. 
+ * violated, or if the norm of pp is greater than mxnewtstep.
  */
 
 static int KINFullNewton(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
@@ -1311,9 +1311,9 @@ static int KINFullNewton(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
         return(STEP_TOO_SMALL);}
     }
   }
- 
+
   /* Attempt (at most MAX_RECVR times) to evaluate function at the new iterate */
-  
+
   fOK = FALSE;
 
   for (ircvr = 1; ircvr <= MAX_RECVR; ircvr++) {
@@ -1350,11 +1350,11 @@ static int KINFullNewton(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
 
   sFdotJp *= ratio;
   sJpnorm *= ratio;
- 
-  if (printfl > 1) 
+
+  if (printfl > 1)
     KINPrintInfo(kin_mem, PRNT_FNORM, "KINSOL", "KINFullNewton", INFO_FNORM, *fnormp);
 
-  if (pnorm > (POINT99 * mxnewtstep)) *maxStepTaken = TRUE; 
+  if (pnorm > (POINT99 * mxnewtstep)) *maxStepTaken = TRUE;
 
   return(KIN_SUCCESS);
 }
@@ -1390,18 +1390,18 @@ static int KINFullNewton(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
  *          || (1/uscale + SUNRabs(uu)) ||
  *
  *
- * If the system function fails unrecoverably at any time, KINLineSearch 
+ * If the system function fails unrecoverably at any time, KINLineSearch
  * returns KIN_SYSFUNC_FAIL which will halt the solver.
  *
- * We attempt to corect recoverable system function failures only before 
- * the alpha-condition loop; i.e. when the solution is updated with the 
- * full Newton step (possibly reduced due to constraint violations). 
+ * We attempt to corect recoverable system function failures only before
+ * the alpha-condition loop; i.e. when the solution is updated with the
+ * full Newton step (possibly reduced due to constraint violations).
  * Once we find a feasible pp, we assume that any update up to pp is
  * feasible.
- * 
- * If the step size is limited due to constraint violations and/or 
+ *
+ * If the step size is limited due to constraint violations and/or
  * recoverable system function failures, we set rlmax=1 to ensure
- * that the update remains feasible during the attempts to enforce 
+ * that the update remains feasible during the attempts to enforce
  * the beta-condition (this is not an issue while enforcing the alpha
  * condition, as rl can only decrease from 1 at that stage)
  */
@@ -1464,7 +1464,7 @@ static int KINLineSearch(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
   }
 
   /* Attempt (at most MAX_RECVR times) to evaluate function at the new iterate */
-  
+
   fOK = FALSE;
 
   for (ircvr = 1; ircvr <= MAX_RECVR; ircvr++) {
@@ -1512,13 +1512,13 @@ static int KINLineSearch(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
   /* Loop until the ALPHA condition is satisfied. Terminate if rl becomes too small */
 
   loop {
-    
+
     /* Evaluate test quantity */
 
     alpha_cond = f1norm + (alpha * slpi * rl);
 
     if (printfl > 2)
-      KINPrintInfo(kin_mem, PRNT_ALPHA, "KINSOL", "KINLinesearch", 
+      KINPrintInfo(kin_mem, PRNT_ALPHA, "KINSOL", "KINLinesearch",
                    INFO_ALPHA, *fnormp, *f1normp, alpha_cond, rl);
 
     /* If ALPHA condition is satisfied, break out from loop */
@@ -1573,7 +1573,7 @@ static int KINLineSearch(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
 
     if (rl < rlmin) {
       /* unew sufficiently distinct from uu cannot be found.
-         copy uu into unew (step remains unchanged) and 
+         copy uu into unew (step remains unchanged) and
          return STEP_TOO_SMALL */
       N_VScale(ONE, uu, unew);
       return(STEP_TOO_SMALL);
@@ -1609,10 +1609,10 @@ static int KINLineSearch(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
         beta_cond = f1norm + (beta * slpi * rl);
 
         if (printfl > 2)
-          KINPrintInfo(kin_mem, PRNT_BETA, "KINSOL", "KINLineSearch", 
+          KINPrintInfo(kin_mem, PRNT_BETA, "KINSOL", "KINLineSearch",
                        INFO_BETA, *f1normp, beta_cond, rl);
 
-      } while (((*f1normp) <= alpha_cond) && 
+      } while (((*f1normp) <= alpha_cond) &&
 	       ((*f1normp) < beta_cond) && (rl < rlmax));
 
     } /* end if (rl == ONE) block */
@@ -1638,7 +1638,7 @@ static int KINLineSearch(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
         beta_cond = f1norm + (beta * slpi * rl);
 
         if (printfl > 2)
-          KINPrintInfo(kin_mem, PRNT_ALPHABETA, "KINSOL", "KINLineSearch", 
+          KINPrintInfo(kin_mem, PRNT_ALPHABETA, "KINSOL", "KINLineSearch",
                        INFO_ALPHABETA, *f1normp, alpha_cond, beta_cond, rl);
 
         if ((*f1normp) > alpha_cond) rldiff = rlinc;
@@ -1652,7 +1652,7 @@ static int KINLineSearch(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
 
       if ( (*f1normp < beta_cond) || ((rldiff < rlmin) && (*f1normp > alpha_cond)) ) {
 
-	/* beta condition could not be satisfied or rldiff too small 
+	/* beta condition could not be satisfied or rldiff too small
 	   and alpha_cond not satisfied, so set unew to last u value
 	   that satisfied the alpha condition and continue */
 
@@ -1660,7 +1660,7 @@ static int KINLineSearch(KINMem kin_mem, realtype *fnormp, realtype *f1normp,
         retval = func(unew, fval, user_data); nfe++;
         if (retval != 0) return(KIN_SYSFUNC_FAIL);
         *fnormp = N_VWL2Norm(fval, fscale);
-        *f1normp = HALF * (*fnormp) * (*fnormp);   
+        *f1normp = HALF * (*fnormp) * (*fnormp);
 
 	/* increment beta-condition failures counter */
 
@@ -1765,7 +1765,7 @@ static int KINStop(KINMem kin_mem, booleantype maxStepTaken, int sflag)
 
   fmax = KINScFNorm(kin_mem, fval, fscale);
 
-  if (printfl > 1) 
+  if (printfl > 1)
     KINPrintInfo(kin_mem, PRNT_FMAX, "KINSOL", "KINStop", INFO_FMAX, fmax);
 
   if (fmax <= fnormtol) return(KIN_SUCCESS);
@@ -1796,10 +1796,10 @@ static int KINStop(KINMem kin_mem, booleantype maxStepTaken, int sflag)
 
   /* Check for consecutive number of steps taken of size mxnewtstep
      and if not maxStepTaken, then set ncscmx to 0 */
- 
+
   if (maxStepTaken) ncscmx++;
   else              ncscmx = 0;
- 
+
   if (ncscmx == 5) return(KIN_MXNEWT_5X_EXCEEDED);
 
   /* Proceed according to the type of linear solver used */
@@ -1826,7 +1826,7 @@ static int KINStop(KINMem kin_mem, booleantype maxStepTaken, int sflag)
       if (eval_omega) {
         omexp = SUNMAX(ZERO,(fnorm/fnormtol)-ONE);
         omega = (omexp > TWELVE)? omega_max : SUNMIN(omega_min*SUNRexp(omexp), omega_max);
-      }   
+      }
       /* Check if making satisfactory progress */
 
       if (fnorm > omega*fnorm_sub) {
@@ -1897,27 +1897,27 @@ static void KINForcingTerm(KINMem kin_mem, realtype fnormp)
 
     linmodel_norm = SUNRsqrt((fnorm * fnorm) + (TWO * sFdotJp) + (sJpnorm * sJpnorm));
 
-    /* form the safeguarded for choice #1 */ 
+    /* form the safeguarded for choice #1 */
 
-    eta_safe = SUNRpowerR(eta, ealpha); 
+    eta_safe = SUNRpowerR(eta, ealpha);
     eta = SUNRabs(fnormp - linmodel_norm) / fnorm;
   }
 
   /* choice #2 forcing term */
 
   if (etaflag == KIN_ETACHOICE2) {
-    eta_safe = egamma * SUNRpowerR(eta, ealpha); 
-    eta = egamma * SUNRpowerR((fnormp / fnorm), ealpha); 
+    eta_safe = egamma * SUNRpowerR(eta, ealpha);
+    eta = egamma * SUNRpowerR((fnormp / fnorm), ealpha);
   }
 
   /* apply safeguards */
- 
+
   if(eta_safe < POINT1) eta_safe = ZERO;
   eta = SUNMAX(eta, eta_safe);
   eta = SUNMAX(eta, eta_min);
   eta = SUNMIN(eta, eta_max);
 
-  return; 
+  return;
 }
 
 
@@ -1964,13 +1964,13 @@ static realtype KINScSNorm(KINMem kin_mem, N_Vector v, N_Vector u)
   return(length);
 }
 
-/* 
+/*
  * =================================================================
  * KINSOL Verbose output functions
  * =================================================================
  */
 
-/* 
+/*
  * KINPrintInfo
  *
  * KINPrintInfo is a high level error handling function
@@ -1981,8 +1981,8 @@ static realtype KINScSNorm(KINMem kin_mem, N_Vector v, N_Vector u)
 #define ihfun    (kin_mem->kin_ihfun)
 #define ih_data  (kin_mem->kin_ih_data)
 
-void KINPrintInfo(KINMem kin_mem, 
-                  int info_code, const char *module, const char *fname, 
+void KINPrintInfo(KINMem kin_mem,
+                  int info_code, const char *module, const char *fname,
                   const char *msgfmt, ...)
 {
   va_list ap;
@@ -1990,10 +1990,10 @@ void KINPrintInfo(KINMem kin_mem,
   char retstr[30];
   int ret;
 
-  /* Initialize argument processing 
+  /* Initialize argument processing
    (msgfrmt is the last required argument) */
 
-  va_start(ap, msgfmt); 
+  va_start(ap, msgfmt);
 
   if (info_code == PRNT_RETVAL) {
 
@@ -2041,7 +2041,7 @@ void KINPrintInfo(KINMem kin_mem,
 
 
   } else {
-  
+
     /* Compose the message */
 
     vsprintf(msg, msgfmt, ap);
@@ -2061,15 +2061,15 @@ void KINPrintInfo(KINMem kin_mem,
 
 
 /*
- * KINInfoHandler 
+ * KINInfoHandler
  *
  * This is the default KINSOL info handling function.
- * It sends the info message to the stream pointed to by kin_infofp 
+ * It sends the info message to the stream pointed to by kin_infofp
  */
 
 #define infofp (kin_mem->kin_infofp)
 
-void KINInfoHandler(const char *module, const char *function, 
+void KINInfoHandler(const char *module, const char *function,
                     char *msg, void *data)
 {
   KINMem kin_mem;
@@ -2077,42 +2077,42 @@ void KINInfoHandler(const char *module, const char *function,
   /* data points to kin_mem here */
 
   kin_mem = (KINMem) data;
-  
+
 #ifndef NO_FPRINTF_OUTPUT
   if (infofp != NULL) {
     fprintf(infofp,"\n[%s] %s\n",module, function);
     fprintf(infofp,"   %s\n",msg);
   }
-#endif  
+#endif
 
 }
 
-/* 
+/*
  * =================================================================
  * KINSOL Error Handling functions
  * =================================================================
  */
 
 /*
- * KINProcessError 
+ * KINProcessError
  *
  * KINProcessError is a high level error handling function.
  * - If cv_mem==NULL it prints the error message to stderr.
- * - Otherwise, it sets up and calls the error handling function 
+ * - Otherwise, it sets up and calls the error handling function
  *   pointed to by cv_ehfun.
  */
 
 #define ehfun    (kin_mem->kin_ehfun)
 #define eh_data  (kin_mem->kin_eh_data)
 
-void KINProcessError(KINMem kin_mem, 
-                    int error_code, const char *module, const char *fname, 
+void KINProcessError(KINMem kin_mem,
+                    int error_code, const char *module, const char *fname,
                     const char *msgfmt, ...)
 {
   va_list ap;
   char msg[256];
 
-  /* Initialize the argument pointer variable 
+  /* Initialize the argument pointer variable
      (msgfmt is the last required argument to KINProcessError) */
 
   va_start(ap, msgfmt);
@@ -2137,11 +2137,11 @@ void KINProcessError(KINMem kin_mem,
   return;
 }
 
-/* 
- * KINErrHandler 
+/*
+ * KINErrHandler
  *
  * This is the default error handling function.
- * It sends the error message to the stream pointed to by kin_errfp 
+ * It sends the error message to the stream pointed to by kin_errfp
  */
 
 #define errfp    (kin_mem->kin_errfp)
@@ -2181,18 +2181,18 @@ void KINErrHandler(int error_code, const char *module,
 /*
  * KINPicardAA
  *
- * This routine is the main driver for the Picard iteration with 
- * acclerated fixed point. 
+ * This routine is the main driver for the Picard iteration with
+ * acclerated fixed point.
  */
 
-static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R, 
+static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
                        realtype *gamma, realtype *fmaxptr)
 {
-  int retval, ret; 
+  int retval, ret;
   long int iter;
   realtype fmax, epsmin, fnormp;
   N_Vector delta, gval;
-  
+
   delta = kin_mem->kin_vtemp1;
   gval = kin_mem->kin_gval;
   ret = CONTINUE_ITERATIONS;
@@ -2216,8 +2216,8 @@ static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
       if(!noMinEps) eps = SUNMAX(epsmin, eps);
     }
 
-    /* evaluate g = uu - L^{-1}func(uu) and return if failed.  
-       For Picard, assume that the fval vector has been filled 
+    /* evaluate g = uu - L^{-1}func(uu) and return if failed.
+       For Picard, assume that the fval vector has been filled
        with an eval of the nonlinear residual prior to this call. */
     retval = KINPicardFcnEval(kin_mem, gval, uu, fval);
 
@@ -2226,7 +2226,7 @@ static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
       break;
     }
 
-    if (maa == 0) { 
+    if (maa == 0) {
       N_VScale(ONE, gval, unew);
     }
     else {  /* use Anderson, if desired */
@@ -2236,7 +2236,7 @@ static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
 
     /* Fill the Newton residual based on the new solution iterate */
     retval = func(unew, fval, user_data); nfe++;
-    
+
     if (retval < 0) {
       ret = KIN_SYSFUNC_FAIL;
       break;
@@ -2247,8 +2247,8 @@ static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
     fmax = KINScFNorm(kin_mem, fval, fscale); /* measure  || F(x) ||_max */
     fnorm = fmax;
     *fmaxptr = fmax;
-    
-    if (printfl > 1) 
+
+    if (printfl > 1)
       KINPrintInfo(kin_mem, PRNT_FMAX, "KINSOL", "KINPicardAA", INFO_FMAX, fmax);
 
     /* print the current iter, fnorm, and nfe values if printfl > 0 */
@@ -2259,20 +2259,20 @@ static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
     if (iter >= mxiter) {
       ret = KIN_MAXITER_REACHED;
     }
-    if (fmax <= fnormtol) { 
+    if (fmax <= fnormtol) {
       ret = KIN_SUCCESS;
     }
 
     /* Update with new iterate. */
     N_VScale(ONE, unew, uu);
 
-    if (ret == CONTINUE_ITERATIONS) { 
+    if (ret == CONTINUE_ITERATIONS) {
       /* evaluate eta by calling the forcing term routine */
       if (callForcingTerm) KINForcingTerm(kin_mem, fnormp);
     }
 
     fflush(errfp);
-    
+
   }  /* end of loop; return */
 
   *iterp = iter;
@@ -2280,7 +2280,7 @@ static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
   if (printfl > 0)
     KINPrintInfo(kin_mem, PRNT_RETVAL, "KINSOL", "KINPicardAA", INFO_RETVAL, ret);
 
-  return(ret); 
+  return(ret);
 }
 
 /*
@@ -2295,7 +2295,7 @@ static int KINPicardAA(KINMem kin_mem, long int *iterp, realtype *R,
  * within the linear solve routines.
  *
  * This routine fills gval = uu - L^{-1}F(uu) given uu and fval = F(uu).
- */ 
+ */
 
 static int KINPicardFcnEval(KINMem kin_mem, N_Vector gval, N_Vector uval, N_Vector fval1)
 {
@@ -2347,15 +2347,15 @@ static int KINPicardFcnEval(KINMem kin_mem, N_Vector gval, N_Vector uval, N_Vect
  * Anderson Acceleration.
  */
 
-static int KINFP(KINMem kin_mem, long int *iterp, 
-		 realtype *R, realtype *gamma, 
+static int KINFP(KINMem kin_mem, long int *iterp,
+		 realtype *R, realtype *gamma,
 		 realtype *fmaxptr)
 {
-  int retval, ret; 
+  int retval, ret;
   long int iter;
   realtype fmax;
   N_Vector delta;
-  
+
   delta = kin_mem->kin_vtemp1;
   ret = CONTINUE_ITERATIONS;
   fmax = fnormtol + ONE;
@@ -2373,7 +2373,7 @@ static int KINFP(KINMem kin_mem, long int *iterp,
       break;
     }
 
-    if (maa == 0) { 
+    if (maa == 0) {
       N_VScale(ONE, fval, unew);
     }
     else {  /* use Anderson, if desired */
@@ -2382,10 +2382,10 @@ static int KINFP(KINMem kin_mem, long int *iterp,
 
     N_VLinearSum(ONE, unew, -ONE, uu, delta);
     fmax = KINScFNorm(kin_mem, delta, fscale); /* measure  || g(x)-x || */
-    
-    if (printfl > 1) 
+
+    if (printfl > 1)
       KINPrintInfo(kin_mem, PRNT_FMAX, "KINSOL", "KINFP", INFO_FMAX, fmax);
-    
+
     fnorm = fmax;
     *fmaxptr = fmax;
 
@@ -2397,11 +2397,11 @@ static int KINFP(KINMem kin_mem, long int *iterp,
     if (iter >= mxiter) {
       ret = KIN_MAXITER_REACHED;
     }
-    if (fmax <= fnormtol) { 
+    if (fmax <= fnormtol) {
       ret = KIN_SUCCESS;
     }
-    
-    if (ret == CONTINUE_ITERATIONS) { 
+
+    if (ret == CONTINUE_ITERATIONS) {
       /* Only update solution if taking a next iteration.  */
       /* CSW  Should put in a conditional to send back the newest iterate or
 	 the one consistent with the fval */
@@ -2409,7 +2409,7 @@ static int KINFP(KINMem kin_mem, long int *iterp,
     }
 
     fflush(errfp);
-    
+
   }  /* end of loop; return */
 
   *iterp = iter;
@@ -2417,8 +2417,8 @@ static int KINFP(KINMem kin_mem, long int *iterp,
   if (printfl > 0)
     KINPrintInfo(kin_mem, PRNT_RETVAL, "KINSOL", "KINFP", INFO_RETVAL, ret);
 
-  return(ret); 
-} 
+  return(ret);
+}
 
 
  /* -----------------------------------------------------------------
@@ -2433,8 +2433,8 @@ static int KINFP(KINMem kin_mem, long int *iterp,
  * ========================================================================
  */
 
-static int AndersonAcc(KINMem kin_mem, N_Vector gval, N_Vector fv, 
-		       N_Vector x, N_Vector xold, 
+static int AndersonAcc(KINMem kin_mem, N_Vector gval, N_Vector fv,
+		       N_Vector x, N_Vector xold,
 		       int iter, realtype *R, realtype *gamma)
 {
   int i_pt, i, j, lAA;
@@ -2533,7 +2533,7 @@ static int AndersonAcc(KINMem kin_mem, N_Vector gval, N_Vector fv,
       gamma[i] = N_VDotProd(fv,Q[i]);
     for (i=lAA-1; i > -1; i--) {
       for (j=i+1; j < lAA; j++) {
-        gamma[i] = gamma[i]-R[j*maa+i]*gamma[j]; 
+        gamma[i] = gamma[i]-R[j*maa+i]*gamma[j];
       }
       gamma[i] = gamma[i]/R[i*maa+i];
       N_VLinearSum(ONE,x,-gamma[i],dg[ipt_map[i]],x);
diff --git a/sundials-2.7.0/src/kinsol/kinsol_nicslu.c b/sundials-2.7.0/src/kinsol/kinsol_nicslu.c
new file mode 100644
index 0000000..a34d401
--- /dev/null
+++ b/sundials-2.7.0/src/kinsol/kinsol_nicslu.c
@@ -0,0 +1,479 @@
+/*
+ * -----------------------------------------------------------------
+ * $Revision: 1 $
+ * $Date: 2018-04-05 13:23:31 +0100 (Thu, 05 Apr 2018) $
+ * -----------------------------------------------------------------
+ * Programmer(s): Lennart M. Schumacher @ RTE
+ * -----------------------------------------------------------------
+ * LLNS Copyright Start
+ * Copyright (c) 2014, Lawrence Livermore National Security
+ * This work was performed under the auspices of the U.S. Department
+ * of Energy by Lawrence Livermore National Laboratory in part under
+ * Contract W-7405-Eng-48 and in part under Contract DE-AC52-07NA27344.
+ * Produced at the Lawrence Livermore National Laboratory.
+ * All rights reserved.
+ * For details, see the LICENSE file.
+ * LLNS Copyright End
+ * -----------------------------------------------------------------
+ * This is the implementation file for the KINNICSLU linear solver.
+ * -----------------------------------------------------------------
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <sundials/sundials_math.h>
+
+#include "kinsol/kinsol_nicslu.h"
+#include "kinsol_impl.h"
+#include "kinsol_sparse_impl.h"
+#include "sundials/sundials_nicslu_impl.h"
+
+/* Constants */
+
+#define ONE RCONST(1.0)
+#define TWO RCONST(2.0)
+#define TWOTHIRDS RCONST(0.6666666666666667)
+
+/* KINNICSLU linit, lsetup, lsolve, and lfree routines */
+
+static int kinNICSLUInit(KINMem kin_mem);
+static int kinNICSLUSetup(KINMem kin_mem);
+static int kinNICSLUSolve(KINMem kin_mem, N_Vector x, N_Vector b,
+                          realtype *sJpnorm, realtype *sFdotJp);
+static int kinNICSLUFree(KINMem kin_mem);
+
+/*
+ * -----------------------------------------------------------------
+ * kinNICSLU
+ * -----------------------------------------------------------------
+ * This routine initializes the memory record and sets various function
+ * fields specific to the KINSOL / NICSLU linear solver module.
+ * KINNICSLU first calls the existing lfree routine if this is not NULL.
+ * Then it sets the kin_linit, kin_lsetup, kin_lsolve, kin_lperf, and
+ * kin_lfree fields in (*kin_mem) to be kinNICSLUInit, kinNICSLUSetup,
+ * kinNICSLUSolve, NULL, and , respectively.
+ * It allocates memory for a structure of type kinNICSLUMemRec and sets
+ * the kin_lmem field in (*kin_mem) to the address of this structure.
+ * It sets setupNonNull in (*kin_mem) to TRUE.
+ * Finally, it allocates memory for NICSLU.
+ * The return value is KINSLS_SUCCESS = 0, KINSLS_LMEM_FAIL = -1,
+ * or KINSLS_ILL_INPUT = -2.
+ *
+ * NOTE: The NICSLU linear solver assumes a serial implementation
+ *       of the NVECTOR package. Therefore, KINNICSLU will first
+ *       test for a compatible N_Vector internal representation
+ *       by checking that the function N_VGetArrayPointer exists.
+ * -----------------------------------------------------------------
+ */
+
+int kinNICSLU(void *kin_mem_v, int n, int nnz, int sparsetype) {
+  KINMem kin_mem;
+  KINSlsMem kinsls_mem;
+  SNicsLU *nicslu_data;
+  int flag;
+
+  /* Return immediately if kin_mem is NULL. */
+  if (kin_mem_v == NULL) {
+    KINProcessError(NULL, KINSLS_MEM_NULL, "KINSLS", "kinNICSLU",
+                    MSGSP_KINMEM_NULL);
+    return (KINSLS_MEM_NULL);
+  }
+  kin_mem = (KINMem)kin_mem_v;
+
+  /* Test if the NVECTOR package is compatible with the Direct solver */
+  if (kin_mem->kin_vtemp1->ops->nvgetarraypointer == NULL) {
+    KINProcessError(kin_mem, KINSLS_ILL_INPUT, "KINSLS", "kinNICSLU",
+                    MSGSP_BAD_NVECTOR);
+    return (KINSLS_ILL_INPUT);
+  }
+
+  if (kin_mem->kin_lfree != NULL)
+    kin_mem->kin_lfree(kin_mem);
+
+  /* Set five main function fields in kin_mem. */
+  kin_mem->kin_linit = kinNICSLUInit;
+  kin_mem->kin_lsetup = kinNICSLUSetup;
+  kin_mem->kin_lsolve = kinNICSLUSolve;
+  kin_mem->kin_lfree = kinNICSLUFree;
+
+  /* Get memory for kinSlsMemRec. */
+  kinsls_mem = (KINSlsMem)malloc(sizeof(struct KINSlsMemRec));
+  if (kinsls_mem == NULL) {
+    KINProcessError(kin_mem, KINSLS_MEM_FAIL, "KINSLS", "kinNICSLU",
+                    MSGSP_MEM_FAIL);
+    return (KINSLS_MEM_FAIL);
+  }
+
+  /* Get memory for NICSLUData. */
+
+  kinsls_mem->s_solver_data = (SNicsLU*)malloc(sizeof(SNicsLU));
+  NicsLU_Initialize(kinsls_mem->s_solver_data);
+  nicslu_data = kinsls_mem->s_solver_data;
+
+  if (nicslu_data == NULL) {
+    KINProcessError(kin_mem, KINSLS_MEM_FAIL, "KINSLS", "kinNICSLU",
+                    MSGSP_MEM_FAIL);
+    return (KINSLS_MEM_FAIL);
+  }
+
+  kin_mem->kin_setupNonNull = TRUE;
+
+  /* Set default Jacobian routine and Jacobian data */
+  kinsls_mem->s_jaceval = NULL;
+  kinsls_mem->s_jacdata = kin_mem->kin_user_data;
+  kinsls_mem->sparsetype = sparsetype;
+
+  /* Allocate memory for the sparse Jacobian */
+  kinsls_mem->s_JacMat = SparseNewMat(n,n,nnz,sparsetype);
+  if (kinsls_mem->s_JacMat == NULL) {
+    KINProcessError(kin_mem, KINSLS_MEM_FAIL, "KINSLS", "kinNICSLU",
+                    MSGSP_MEM_FAIL);
+    return (KINSLS_MEM_FAIL);
+  }
+
+  /* This is a direct linear solver */
+  kin_mem->kin_inexact_ls = FALSE;
+
+  /* Attach linear solver memory to the nonlinear solver memory */
+  kin_mem->kin_lmem = kinsls_mem;
+
+  kinsls_mem->s_last_flag = KINSLS_SUCCESS;
+  return (KINSLS_SUCCESS);
+}
+
+/*
+ * -----------------------------------------------------------------
+ * kinNICSLUReInit
+ * -----------------------------------------------------------------
+ * This routine reinitializes memory and flags for a new factorization
+ * (symbolic and numeric) to be conducted at the next solver setup
+ * call.  This routine is useful in the cases where the number of nonzeroes
+ * has changed or if the structure of the linear system has changed
+ * which would require a new symbolic (and numeric factorization).
+ *
+ * The reinit_type argumenmt governs the level of reinitialization:
+ *
+ * reinit_type = 1: The Jacobian matrix will be destroyed and
+ *                  a new one will be allocated based on the nnz
+ *                  value passed to this call. New symbolic and
+ *                  numeric factorizations will be completed at the next
+ *                  solver setup.
+ *
+ * reinit_type = 2: Only symbolic and numeric factorizations will be
+ *                  completed.  It is assumed that the Jacobian size
+ *                  has not exceeded the size of nnz given in the prior
+ *                  call to KINNICSLU.
+ *
+ * This routine assumes no other changes to solver use are necessary.
+ *
+ * The return value is KINSLS_SUCCESS = 0, KINSLS_MEM_NULL = -1,
+ * KINSLS_LMEM_NULL = -2, KINSLS_ILL_INPUT = -3, or KINSLS_MEM_FAIL = -4.
+ *
+ * -----------------------------------------------------------------
+ */
+
+int kinNICSLUReInit(void *kin_mem_v, int n, int nnz, int reinit_type) {
+  KINMem kin_mem;
+  KINSlsMem kinsls_mem;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+
+  /* Return immediately if kin_mem is NULL. */
+  if (kin_mem_v == NULL) {
+    KINProcessError(NULL, KINSLS_MEM_NULL, "KINSLS", "kinNICSLUReInit",
+                    MSGSP_KINMEM_NULL);
+    return (KINSLS_MEM_NULL);
+  }
+  kin_mem = (KINMem)kin_mem_v;
+
+  /* Return immediately if kin_lmem is NULL. */
+  if (kin_mem->kin_lmem == NULL) {
+    KINProcessError(NULL, KINSLS_LMEM_NULL, "KINSLS", "kinNICSLUReInit",
+                    MSGSP_LMEM_NULL);
+    return (KINSLS_LMEM_NULL);
+  }
+  kinsls_mem = (KINSlsMem)(kin_mem->kin_lmem);
+  nicslu_data = (SNicsLU *)kinsls_mem->s_solver_data;
+
+  /* Return if reinit_type is not valid */
+  if ((reinit_type != 1) && (reinit_type != 2)) {
+    KINProcessError(NULL, KINSLS_ILL_INPUT, "KINSLS", "kinNICSLUReInit",
+                    MSGSP_ILL_INPUT);
+    return (KINSLS_ILL_INPUT);
+  }
+
+  JacMat = kinsls_mem->s_JacMat;
+
+  if (reinit_type == 1) {
+
+    /* Destroy previous Jacobian information */
+    if (kinsls_mem->s_JacMat) {
+      SparseDestroyMat(kinsls_mem->s_JacMat);
+    }
+
+    /* Allocate memory for the sparse Jacobian */
+    kinsls_mem->s_JacMat = SparseNewMat(n,n,nnz,kinsls_mem->sparsetype);
+    if (kinsls_mem->s_JacMat == NULL) {
+      KINProcessError(kin_mem, KINSLS_MEM_FAIL, "KINSLS", "KINNICSLU",
+                      MSGSP_MEM_FAIL);
+      return (KINSLS_MEM_FAIL);
+    }
+  }
+  // NicsLU_Destroy(nicslu_data);
+  kinsls_mem->s_first_factorize = 1;
+
+  kinsls_mem->s_last_flag = KINSLS_SUCCESS;
+  return (0);
+}
+
+/*
+ * -----------------------------------------------------------------
+ * KINNICSLU interface functions
+ * -----------------------------------------------------------------
+ */
+
+/*
+  This routine does remaining initializations specific to the KINNICSLU
+  linear solver module.
+  It returns 0 if successful.
+*/
+
+static int kinNICSLUInit(KINMem kin_mem) {
+  KINSlsMem kinsls_mem;
+  kinsls_mem = (KINSlsMem)kin_mem->kin_lmem;
+
+  kinsls_mem->s_nje = 0;
+  kinsls_mem->s_first_factorize = 1;
+
+  kinsls_mem->s_last_flag = 0;
+  return (0);
+}
+
+/*
+  This routine does the setup operations for the KINNICSLU linear
+  solver module.  It calls the Jacobian evaluation routine,
+  updates counters, and calls the LU factorization routine.
+  The return value is either
+     KINSLS_SUCCESS = 0  if successful,
+     +1  if the jac routine failed recoverably or the
+         LU factorization failed, or
+     -1  if the jac routine failed unrecoverably.
+*/
+
+static int kinNICSLUSetup(KINMem kin_mem) {
+  int retval;
+  KINSlsMem kinsls_mem;
+  KINSlsSparseJacFn jaceval;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+  void *jacdata;
+  realtype uround_twothirds;
+  int num; // Number of THREADS
+  static int (*performFactorization)(SNicsLU *) = NULL;
+  static int (*performReFactorization)(SNicsLU *, real__t *) = NULL;
+
+  uround_twothirds = SUNRpowerR(kin_mem->kin_uround, TWOTHIRDS);
+
+  kinsls_mem = (KINSlsMem)(kin_mem->kin_lmem);
+
+  nicslu_data = (SNicsLU *)kinsls_mem->s_solver_data;
+
+  jaceval = kinsls_mem->s_jaceval;
+  jacdata = kinsls_mem->s_jacdata;
+  JacMat = kinsls_mem->s_JacMat;
+
+  /* Check that Jacobian eval routine is set */
+  if (jaceval == NULL) {
+    KINProcessError(kin_mem, KINSLS_JAC_NOSET, "KINSLS", "kinNICSLUSetup",
+                    MSGSP_JAC_NOSET);
+    free(kinsls_mem);
+    kinsls_mem = NULL;
+    return (KINSLS_JAC_NOSET);
+  }
+
+  /* Increment nje counter and call Jacobian eval routine. */
+  kinsls_mem->s_nje++;
+  retval = jaceval(kin_mem->kin_uu, kin_mem->kin_fval, JacMat, jacdata,
+                   kin_mem->kin_vtemp1, kin_mem->kin_vtemp2);
+
+  if (retval < 0) {
+    KINProcessError(kin_mem, KINSLS_JACFUNC_UNRECVR, "KINSLS",
+		    "kinNICSLUSetup",MSGSP_JACFUNC_FAILED);
+    kinsls_mem->s_last_flag = KINSLS_JACFUNC_UNRECVR;
+    return (KINSLS_JACFUNC_UNRECVR);
+  }
+  if (retval == 1) {
+    kinsls_mem->s_first_factorize = 1;
+  }
+  if (retval > 1) {
+    kinsls_mem->s_last_flag = KINSLS_JACFUNC_RECVR;
+    return (+1);
+  }
+
+  uint__t n = JacMat->NP;
+  uint__t nnz = JacMat->NNZ;
+  uint__t *ai = JacMat->indexvals;
+  uint__t *ap = JacMat->indexptrs;
+  real__t *ax = JacMat->data;
+  int ret;
+  if (kinsls_mem->s_first_factorize) {
+    /* ------------------------------------------------------------
+       Get the symbolic factorization
+       ------------------------------------------------------------*/
+
+    if (nicslu_data == NULL) {
+      KINProcessError(kin_mem, KINSLS_PACKAGE_FAIL, "KINSLS", "kinNICSLUSetup",
+                      MSGSP_PACKAGE_FAIL);
+      return (+1);
+    }
+
+    ret = NicsLU_CreateMatrix(nicslu_data, n, nnz, ax, ai, ap);
+    if (ret != NICS_OK){
+      KINProcessError(kin_mem, KINSLS_PACKAGE_FAIL, "KINSLS", "kinNICSLUSetup::NicsLU_CreateMatrix",
+                      MSGSP_MEM_FAIL);
+        // printf("Error in setup, ret is %d for NicsLU_CreateMatrix/n", ret);
+        // printf("N : %d\t NNZ : %d\t ap[N] = %d\n",n,nnz,ap[n]);
+    }
+    switch(kinsls_mem->sparsetype){
+    	case CSC_MAT : nicslu_data->cfgi[0] = 1;
+		       break;
+        case CSR_MAT : nicslu_data->cfgi[0] = 0;
+		       break;
+        default : nicslu_data->cfgi[0] = 1;
+    }
+
+    ret = NicsLU_Analyze(nicslu_data);        
+    if (ret != NICS_OK){
+      KINProcessError(kin_mem, KINSLS_PACKAGE_FAIL, "KINSLS", "kinNICSLUSetup::NicsLU_Analyze",
+                      MSGSP_PACKAGE_FAIL);
+        // printf("Error in setup, ret is %d for NicsLU_Analyze\n", ret);
+    }
+    char *numth = getenv("THREADS");
+    // numth = number of threads
+    if (numth != NULL && atoi(numth) > 1) {
+      ret = NicsLU_CreateScheduler(nicslu_data);
+      // printf("suggestion: %s.\n", ret == 0 ? "parallel" : "sequential");
+      num = atoi(numth);
+      ret = NicsLU_CreateThreads(nicslu_data, num, TRUE);
+      ret = NicsLU_BindThreads(nicslu_data, FALSE);
+      performFactorization = &NicsLU_Factorize_MT;
+      performReFactorization = &NicsLU_ReFactorize_MT;
+      // if (ret == NICS_OK)
+      //  printf("%d threads created\n", num);
+    } else {
+      performFactorization = &NicsLU_Factorize;
+      performReFactorization = &NicsLU_ReFactorize;
+      num = 1;
+    }
+
+    if (ret != NICS_OK) {
+      KINProcessError(kin_mem, KINSLS_PACKAGE_FAIL, "KINSLS", "kinNICSLUSetup",
+                      MSGSP_PACKAGE_FAIL);
+      return (KINSLS_PACKAGE_FAIL);
+    }
+
+    /* ------------------------------------------------------------
+      Compute the LU factorization of  the Jacobian.
+      ------------------------------------------------------------*/
+    performFactorization(nicslu_data);
+    kinsls_mem->s_first_factorize = 0;
+  } else {
+    performReFactorization(nicslu_data, ax);
+
+    /*-----------------------------------------------------------
+      Check if a cheap estimate of the reciprocal of the condition
+      number is getting too small.  If so, delete
+      the prior numeric factorization and recompute it.
+      -----------------------------------------------------------*/
+    real__t cond;
+    NicsLU_ConditionNumber(nicslu_data, &cond);
+    // if (kin_mem->kin_printfl) {
+    //  printf("%e\n",cond);
+    //}
+
+    /* Condition number may be getting large.
+    Compute more accurate estimate */
+
+   if(cond> TWOTHIRDS){
+
+      /* More accurate estimate also says condition number is
+         large, so recompute the numeric factorization */
+     //if (kin_mem->kin_printfl) { ;
+     //  printf("Condition number too large, not using refactorization but factorization instead ... \n");
+     //}
+      performFactorization(nicslu_data);
+    }
+  }
+
+  kinsls_mem->s_last_flag = KINSLS_SUCCESS;
+  return (0);
+}
+
+/*
+  This routine handles the solve operation for the KINNICSLU linear
+  solver module.  It calls the KLU solve routine,
+  then returns KINSLS_SUCCESS = 0.
+*/
+
+static int kinNICSLUSolve(KINMem kin_mem, N_Vector x, N_Vector b,
+                          realtype *sJpnorm, realtype *sFdotJp) {
+  int flag;
+  KINSlsMem kinsls_mem;
+  SNicsLU *nicslu_data;
+  SlsMat JacMat;
+  realtype *xd;
+
+  kinsls_mem = (KINSlsMem)kin_mem->kin_lmem;
+  JacMat = kinsls_mem->s_JacMat;
+
+  nicslu_data = (SNicsLU *)kinsls_mem->s_solver_data;
+
+  /* Copy the right-hand side into x */
+  N_VScale(ONE, b, x);
+  xd = N_VGetArrayPointer(x);
+
+  /* Call KLU to solve the linear system */
+  flag = NicsLU_Solve(nicslu_data, xd);
+
+  if (flag != NICS_OK) {
+    KINProcessError(kin_mem, KINSLS_PACKAGE_FAIL, "KINSLS", "kinNICSLUSolve",
+                    MSGSP_PACKAGE_FAIL);
+    return (KINSLS_PACKAGE_FAIL);
+  }
+
+  /* Compute the term sFdotJp for use in the linesearch routine.
+     This term is subsequently corrected if the step is reduced by
+     constraints or the linesearch.
+
+     sFdotJp is the dot product of the scaled f vector and the scaled
+     vector J*p, where the scaling uses fscale.                            */
+
+  N_VProd(b, kin_mem->kin_fscale, b);
+  N_VProd(b, kin_mem->kin_fscale, b);
+  *sFdotJp = N_VDotProd(kin_mem->kin_fval, b);
+
+  kinsls_mem->s_last_flag = KINSLS_SUCCESS;
+  return (KINSLS_SUCCESS);
+}
+
+/*
+  This routine frees memory specific to the KINNICSLU linear solver.
+*/
+
+static int kinNICSLUFree(KINMem kin_mem) {
+  KINSlsMem kinsls_mem;
+  SNicsLU *nicslu_data;
+
+  kinsls_mem = (KINSlsMem)kin_mem->kin_lmem;
+  nicslu_data = (SNicsLU *)kinsls_mem->s_solver_data;
+  NicsLU_Destroy(nicslu_data);
+
+  if (kinsls_mem->s_JacMat) {
+    SparseDestroyMat(kinsls_mem->s_JacMat);
+    kinsls_mem->s_JacMat = NULL;
+  }
+
+  free(nicslu_data);
+  free(kin_mem->kin_lmem);
+}
